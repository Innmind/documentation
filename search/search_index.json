{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Innmind","text":"<p>Innmind bridges Object Oriented Programming and Functional Programming in a coherent ecosystem to bring high level abstraction to life.</p> <p>This documentation will show you how to move from simple scripts all the way to distributed systems (and all the steps in-between) by using a single way to code.</p> <p>If you've seen modern Java, C#, Rust, Swift and co you should find Innmind very familiar.</p> Sneak peek <p>The code below shows how the declarative nature of Innmind abstracts away the complexity.</p> <pre><code>$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('somewhere/data/'))\n    -&gt;unwrap()\n    -&gt;get(Name::of('avatars'))\n    -&gt;keep(Instance::of(Directory::class))\n    -&gt;map(\n        static fn(Directory $directory) =&gt; $directory-&gt;add(File::named(\n            'users.csv',\n            Content::ofLines(\n                $orm\n                    -&gt;repository(User::class)\n                    -&gt;all()\n                    -&gt;map(static fn(User $user) =&gt; $user-&gt;toArray())\n                    -&gt;map(static fn(array $user) =&gt; \\implode(',', $user))\n                    -&gt;map(Str::of(...))\n                    -&gt;map(Line::of(...)),\n            ),\n        )),\n    )\n    -&gt;map(Tar::encode($os-&gt;clock()))\n    -&gt;map(Gzip::encode())\n    -&gt;match(\n        static fn(File $tar) =&gt; Response::of(\n            StatusCode::ok,\n            ProtocolVersion::v11,\n            null,\n            $tar-&gt;content(),\n        ),\n        static fn() =&gt; Response::of(\n            StatusCode::noContent,\n            ProtocolVersion::v11,\n        ),\n    );\n</code></pre> <p>This example sends an HTTP response of a <code>.tar.gz</code> containing all files contained in an <code>avatars</code> directory and with a CSV of all users stored in a database. All this is done with the guarantee that you won't run in \"out of memory\" errors, and other advantages you'll learn throughout this documentation.</p> <p>By following the links at the bottom of each page you'll progressively learn your way through Innmind. While the Philosophy chapter is an important part you can skip to the Getting started one if you want to feel what it's like to code with Innmind.</p>"},{"location":"packages/","title":"Other Packages","text":""},{"location":"packages/#access-control-list","title":"Access Control List","text":"<p>Immutable object version to define unix permissions.</p> <pre><code>composer require innmind/acl:~3.1\n</code></pre> <pre><code>use Innmind\\ACL\\{\n    ACL,\n    User,\n    Group,\n    Mode,\n};\n\n$acl = ACL::of('r---w---x user:group');\n\n$acl-&gt;allows(User::of('foo'), Group::of('bar'), Mode::read); // false\n$acl-&gt;allows(User::of('foo'), Group::of('bar'), Mode::execute); // true\n</code></pre> <p>Repository</p>"},{"location":"packages/#coding-standard","title":"Coding standard","text":"<p>Specifies the code style used throughout Innmind.</p> <pre><code>composer require --dev innmind/coding-standard:~2.0\n</code></pre> .php-cs-fixer.dist.php<pre><code>&lt;?php\n\nreturn \\Innmind\\CodingStandard\\CodingStandard::config(['src', 'proofs']);\n</code></pre> <pre><code>vendor/bin/php-cs-fixer fix\n</code></pre> <p>Repository</p>"},{"location":"packages/#colour","title":"Colour","text":"<p>Immutables objects to specify colours and switch between the notations (RGBA, HSL and CMYK).</p> <pre><code>composer install innmind/colour:~4.2\n</code></pre> <pre><code>use Innmind\\Colour\\Colour;\n\n$rgba = Colour::of('#3399ff');\n$hsla = Colour::of('hsl(210, 100%, 60%)');\n$cmyka = Colour::of('device-cmyk(80%, 40%, 0%, 0%)');\n$rgba = Colour::blue-&gt;toRGBA();\n</code></pre> <p>Repository</p>"},{"location":"packages/#cron","title":"Cron","text":"<p>Immutable objects to define cron jobs and install them on a machine (local or remote).</p> <pre><code>composer require innmind/cron '~4.0'\n</code></pre> <pre><code>use Innmind\\Cron\\{\n    Crontab,\n    Job,\n};\nuse Innmind\\Server\\Control\\Server\\Command;\n\n$install = Crontab::forUser(\n    'admin',\n    Job::of(\n        Job\\Schedule::everyDayAt(10, 30),\n        Command::foreground('say hello'),\n    ),\n);\n$install($os-&gt;control());\n</code></pre> <p>Repository</p>"},{"location":"packages/#encoding","title":"Encoding","text":"<p>Allows to <code>tar</code> directories and <code>gzip</code> files in a memory safe way.</p> <pre><code>use Innmind\\Filesystem\\{\n    File,\n    Name,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Encoding\\{\n    Gzip,\n    Tar,\n};\n\n$tar = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some/directory/'))\n    -&gt;unwrap()\n    -&gt;get(Name::of('data'))\n    -&gt;map(Tar::encode($os-&gt;clock()))\n    -&gt;map(Gzip::compress())\n    -&gt;match(\n        static fn(File\\Content $file) =&gt; $file,\n        static fn() =&gt; null,\n    );\n</code></pre> <p>Repository</p>"},{"location":"packages/#hash","title":"Hash","text":"<p>Allows to compute the hash of files in a memory safe way.</p> <pre><code>use Innmind\\Filesystem\\Name;\nuse Innmind\\Url\\Path;\nuse Innmind\\Hash\\{\n    Hash,\n    Value,\n};\nuse Innmind\\Immutable\\Set;\n\n$hash = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some-folder/'))\n    -&gt;unwrap()\n    -&gt;get(Name::of('some-file'))\n    -&gt;map(Hash::sha512-&gt;ofFile(...))\n    -&gt;match(\n        static fn(Value $hash): string =&gt; $hash-&gt;hex(),\n        static fn() =&gt; null,\n    );\n</code></pre> <p>Repository</p>"},{"location":"packages/#html","title":"Html","text":"<p>Allows to parse HTML files to immutable objects (built on top of XML).</p> <pre><code>use Innmind\\Html\\Reader;\nuse Innmind\\HttpTransport\\Success;\nuse Innmind\\Http\\{\n    Request,\n    Method,\n    ProtocolVersion,\n};\nuse Innmind\\Url\\Url;\nuse Innmind\\Xml\\Node;\nuse Innmind\\Immutable\\Attempt;\n\n$read = Reader::new();\n\n$html = $os\n    -&gt;remote()\n    -&gt;http()(Request::of(\n        Url::of('https://github.com/'),\n        Method::get,\n        ProtocolVersion::v11,\n    ))\n    -&gt;attempt(static fn() =&gt; new \\RuntimeException)\n    -&gt;map(static fn(Success $success) =&gt; $success-&gt;response()-&gt;body())\n    -&gt;flatMap($read);\n$html; // instance of Attempt&lt;Node&gt;\n</code></pre> <p>Repository</p>"},{"location":"packages/#http-authentication","title":"HTTP Authentication","text":"<p>Simple structures to define the ways to extract the identity from a <code>ServerRequest</code>.</p> <p>Repository</p>"},{"location":"packages/#http-session","title":"HTTP Session","text":"<p>Object approach to handle HTTP sessions without a global state.</p> <p>Repository</p>"},{"location":"packages/#log-reader","title":"Log reader","text":"<p>Allows to read Apache access and Monolog logs into immutable objects in a memory safe way.</p> <pre><code>composer require innmind/log-reader '~5.4'\n</code></pre> <pre><code>use Innmind\\LogReader\\{\n    Reader,\n    LineParser\\Monolog,\n    Log,\n};\nuse Innmind\\Filesystem\\{\n    File,\n    Name,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Predicate\\Instance;\nuse Psr\\Log\\LogLevel;\n\n$read = Reader::of(\n    Monolog::of($os-&gt;clock()),\n);\n$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('var/logs/'))\n    -&gt;unwrap()\n    -&gt;get(Name::of('prod.log'))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;map(static fn($file) =&gt; $file-&gt;content())\n    -&gt;toSequence()\n    -&gt;flatMap($read)\n    -&gt;filter(\n        static fn(Log $log) =&gt; $log\n            -&gt;attribute('level')\n            -&gt;filter(static fn($level) =&gt; $level-&gt;value() === LogLevel::CRITICAL)\n            -&gt;match(\n                static fn() =&gt; true,\n                static fn() =&gt; false,\n            ),\n    )\n    -&gt;foreach(\n        static fn($log) =&gt; $log\n            -&gt;attribute('message')\n            -&gt;match(\n                static fn($attribute) =&gt; print($attribute-&gt;value()),\n                static fn() =&gt; print('No message found'),\n            ),\n    );\n</code></pre> <p>Repository</p>"},{"location":"packages/#rabbitmq-management","title":"RabbitMQ management","text":"<p>Object API on top of the <code>rabbitmqadmin</code> CLI command.</p> <p>Repository</p>"},{"location":"packages/#robotstxt","title":"Robots.txt","text":"<p>Allows to parse <code>robots.txt</code> files.</p> <pre><code>composer require innmind/robots-txt '~6.3'\n</code></pre> <pre><code>use Innmind\\RobotsTxt\\{\n    Parser,\n    RobotsTxt,\n};\nuse Innmind\\Url\\Url;\n\n$parse = Parser::of(\n    $os-&gt;remote()-&gt;http(),\n    'My user agent',\n);\n$robots = $parse(Url::of('https://github.com/robots.txt'))-&gt;match(\n    static fn(RobotsTxt $robots) =&gt; $robots,\n    static fn() =&gt; throw new \\RuntimeException('robots.txt not found'),\n);\n$robots-&gt;disallows('My user agent', Url::of('/humans.txt')); // false\n$robots-&gt;disallows('My user agent', Url::of('/any/other/url')); // true\n</code></pre> <p>Repository</p>"},{"location":"packages/#ssh-key-provider","title":"SSH key provider","text":"<p>Allows to fetch a user ssh keys from different sources.</p> <pre><code>composer require innmind/ssh-key-provider:~3.2\n</code></pre> <pre><code>use Innmind\\SshKeyProvider\\{\n    Cache,\n    Merge,\n    Local,\n    Github,\n    PublicKey,\n};\nuse Innmind\\Url\\Path;\n\n$provide = Cache::of(\n    Merge::of(\n        Local::of(\n            $os-&gt;filesystem()-&gt;mount(Path::of($_SERVER['USER'].'/.ssh/'))-&gt;unwrap(),\n        ),\n        Github::of(\n            $os-&gt;remote()-&gt;http(),\n            'GithubUsername',\n        ),\n    ),\n);\n\n$provide()-&gt;foreach(static fn(PublicKey $key) =&gt; print($key-&gt;toString()));\n</code></pre> <p>Repository</p>"},{"location":"packages/#url-resolver","title":"URL resolver","text":"<p>Allows to resolve a target url from a base one. This is useful for crawlers.</p> <pre><code>composer require innmind/url-resolver:~5.1\n</code></pre> <pre><code>use Innmind\\UrlResolver\\UrlResolver;\nuse Innmind\\Url\\Url;\n\n$resolve = UrlResolver::of('http', 'https');\n\n$url = $resolve(\n    Url::of('http://example.com/foo/'),\n    Url::of('./bar/baz?query=string#fragment'),\n);\n// $url resolves to http://example.com/foo/bar/baz?query=string#fragment\n</code></pre> <p>Repository</p>"},{"location":"packages/#validation","title":"Validation","text":"<p>This is a monadic approach to data validation.</p> <pre><code>use Innmind\\Validation\\{\n    Is,\n    Failure,\n};\nuse Innmind\\Immutable\\Sequence;\n\n$valid = [\n    'id' =&gt; 42,\n    'username' =&gt; 'jdoe',\n    'addresses' =&gt; [\n        'address 1',\n        'address 2',\n    ],\n    'submit' =&gt; true,\n];\n$invalid = [\n    'id' =&gt; '42',\n    'addresses' =&gt; [\n        'address 1',\n        null,\n    ],\n    'submit' =&gt; true,\n];\n\n$validate = Is::shape('id', Is::int())\n    -&gt;with('username', Is::string())\n    -&gt;with(\n        'addresses',\n        Is::list(\n            Is::string()-&gt;map(\n                static fn(string $address) =&gt; new YourModel($address),\n            )\n        )\n    );\n$result = $validate($valid)-&gt;match(\n    static fn(array $value) =&gt; $value,\n    static fn() =&gt; throw new \\RuntimeException('invalid data'),\n);\n// Here $result looks like:\n// [\n//      'id' =&gt; 42\n//      'username' =&gt; 'jdoe',\n//      'addresses' [\n//          new YourModel('address 1'),\n//          new YourModel('address 2'),\n//      ],\n//      (1)\n// ]\n$errors = $validate($invalid)-&gt;match(\n    static fn() =&gt; null,\n    static fn(Sequence $failures) =&gt; $failures\n        -&gt;map(static fn(Failure $failure) =&gt; [\n            $failure-&gt;path()-&gt;toString(),\n            $failure-&gt;message(),\n        ])\n        -&gt;toList(),\n);\n// Here $errors looks like:\n// [\n//      ['id', 'Value is not of type int'],\n//      ['$', 'The key username is missing'],\n//      ['addresses', 'Value is not of type string']\n// ]\n</code></pre> <ol> <li>See how the <code>submit</code> key disappeared.</li> </ol> <p>Repository</p>"},{"location":"packages/#xml","title":"XML","text":"<p>Allows to parse XML files to immutable objects.</p> <pre><code>use Innmind\\Xml\\{\n    Reader,\n    Node,\n};\nuse Innmind\\Filesystem\\File\\Content;\nuse Innmind\\Immutable\\Maybe;\n\n$read = Reader::of();\n\n$tree = $read(\n    Content::ofString('&lt;root&gt;&lt;foo some=\"attribute\"/&gt;&lt;/root&gt;')\n); // Maybe&lt;Node&gt;\n</code></pre> <p>Repository</p>"},{"location":"tools/","title":"Tools","text":"<p>All the examples below assume that the folder <code>~/.composer/vendor/bin</code> is part of your <code>$PATH</code> environment variable.</p>"},{"location":"tools/#dependency-graph","title":"Dependency graph","text":"<p>This tool helps to visualize all the dependencies of a package or an organization. The main feature is that it highlight the dependencies that are out of date.</p> <p>This ease the development on Innmind to understand in which order to update packages.</p>"},{"location":"tools/#installation","title":"Installation","text":"<pre><code>composer global require innmind/dependency-graph:~3.5\n</code></pre>"},{"location":"tools/#usage","title":"Usage","text":"OrganizationFrom lockPackage dependenciesPackage dependents <pre><code>dependency-graph vendor innmind\n</code></pre> <p>You can see a lot of red because the refactoring to the monadic style is still under way.</p> <pre><code>cd to/your/project &amp;&amp; dependency-graph from-lock\n</code></pre> <p></p> <pre><code>dependency-graph of innmind/cli\n</code></pre> <p></p> <pre><code>dependency-graph depends-on innmind/cli innmind\n</code></pre> <p></p>"},{"location":"tools/#macos-app","title":"macOS App","text":"<p>Instead of manually executing the CLI commands you can use this macOS app. You only need to specify the organization you want to visualize and the app will fetch everything necessary.</p> <p></p>"},{"location":"tools/#website","title":"Website","text":"<p>The macOS App is also available as a website at http://innmind.net.</p>"},{"location":"tools/#lab-station","title":"Lab station","text":"<p>This tool automatically runs your tests, psalm and code style checker everytime you save a file.</p>"},{"location":"tools/#installation_1","title":"Installation","text":"<pre><code>composer global require innmind/lab-station:~4.1\n</code></pre>"},{"location":"tools/#usage_1","title":"Usage","text":"<pre><code>cd to/package/ &amp;&amp; lab-station\n</code></pre>"},{"location":"tools/#git-release","title":"Git release","text":"<p>This is a tool to create SemVer tags.</p>"},{"location":"tools/#installation_2","title":"Installation","text":"<pre><code>composer global require innmind/git-release:~3.1\n</code></pre>"},{"location":"tools/#usage_2","title":"Usage","text":"<pre><code>git-release major\n</code></pre> <p>If the last major version is <code>1.2.3</code> this will create the tag <code>2.0.0</code> and push it to the remote.</p> <p>There's also the <code>minor</code> and <code>bugfix</code> commands.</p>"},{"location":"blog/","title":"Blog","text":"<p> RSS Feed</p>"},{"location":"blog/2024/06/living-a-simpler-lazy-life/","title":"Living a simpler lazy life","text":"<p>The <code>Sequence</code> monad is very powerful as it allows you to switch from an in memory strategy to a lazy one by only modifying the constructor, the rest of the program is unchanged.</p> <p>However composing correctly lazy <code>Sequence</code>s has been challenging... until now!</p> <p>To better describe the problem let's use this function that builds an xml file:</p> <pre><code>use Innmind\\Filesystem\\File\\Content;\nuse Innmind\\Xml\\{\n    Node\\Document,\n    Node\\Text,\n    Element\\Element,\n};\nuse Innmind\\Immutable\\{\n    Sequence,\n    Maybe,\n};\n\n/**\n * @param Sequence&lt;string&gt; $entries\n */\nfunction build(Sequence $entries): Content\n{\n    $xml = Document::of(\n        Document\\Version::of(1, 0)\n        Maybe::nothing(),\n        Maybe::just(Document\\Encoding::of('utf-8')),\n        Sequence::of(\n            Element::of(\n                'log',\n                null,\n                Sequence::of(\n                    Element::of(\n                        'entries',\n                        null,\n                        $entries\n                            -&gt;map(Text::of(...))\n                            -&gt;map(Sequence::of(...))\n                            -&gt;map(static fn(Sequence $children) =&gt; Element::of(\n                                'entry',\n                                null,\n                                $children,\n                            )),\n                    ),\n                ),\n            ),\n        ),\n    );\n\n    return $xml-&gt;asContent();\n}\n</code></pre> <p>When run this code would produce an xml file like:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;log&gt;\n    &lt;entries&gt;\n        &lt;entry&gt;entry-1&lt;/entry&gt;\n        &lt;entry&gt;entry-2&lt;/entry&gt;\n        &lt;entry&gt;etc...&lt;/entry&gt;\n    &lt;/entries&gt;\n&lt;/log&gt;\n</code></pre> <p>Internally the <code>$xml-&gt;asContent()</code> will flatten the nesting of elements to a single <code>Sequence</code> containing each line of the file.</p> <p>If you don't have many entries this will work fine. But if you know you'll have to handle a number of entries that can't fit in memory you'll use a lazy <code>Sequence</code> for <code>$entries</code>.</p> <p>The <code>build</code> function will fail in this case with an out of memory error. The problem lies with the <code>Sequence</code>s used for the <code>Document</code> and <code>log</code> children, we use the <code>::of()</code> constructor meaning in memory. So when the elements are flattened it will keep everything in memory.</p> <p>A simple fix would be to replace <code>::of()</code> by <code>::lazyStartingWith()</code> like so:</p> <pre><code>function build(Sequence $entries): Content\n{\n    $xml = Document::of(\n        Document\\Version::of(1, 0)\n        Maybe::nothing(),\n        Maybe::just(Document\\Encoding::of('utf-8')),\n        Sequence::lazyStartingWith(\n            Element::of(\n                'log',\n                null,\n                Sequence::lazyStartingWith(\n                    Element::of(\n                        'entries',\n                        null,\n                        $entries\n                            -&gt;map(Text::of(...))\n                            -&gt;map(Sequence::of(...))\n                            -&gt;map(static fn(Sequence $children) =&gt; Element::of(\n                                'entry',\n                                null,\n                                $children,\n                            )),\n                    ),\n                ),\n            ),\n        ),\n    );\n\n    return $xml-&gt;asContent();\n}\n</code></pre> <p>This indeed fixes the problem but it brings new ones.</p> <p>The first one is that even if you use an in memory <code>Sequence</code> for the entries the file is still lazy. This complexifies debugging and testing because internally it uses generators and the stack traces are harder to read.</p> <p>But the main problem is about implicits. When creating the function you have to know if the data you handle is lazy or not. This is tricky because you can get it wrong or even forget to check and it will crash in production. But even if you get it right nothing prevents someone in the future to use the function with a lazy <code>Sequence</code> while it was designed for in memory usage. And once again it will crash in production.</p> <p>Thanks to <code>innmind/immutable</code> <code>5.8</code> this problem no longer have to exist.</p> <p>The solution is to start with the input data that may or may not be lazy and compose it through the <code>Identity</code> monad. With this the function becomes:</p> <pre><code>function build(Sequence $entries): Content\n{\n    return $entries\n        -&gt;map(Text::of(...))\n        -&gt;map(Sequence::of(...))\n        -&gt;map(static fn(Sequence $children) =&gt; Element::of(\n            'entry',\n            null,\n            $children,\n        ))\n        -&gt;toIdentity()\n        -&gt;map(static fn(Sequence $entries) =&gt; Element::of(\n            'entries',\n            null,\n            $entries,\n        ))\n        -&gt;toSequence()\n        -&gt;toIdentity()\n        -&gt;map(static fn(Sequence $entries) =&gt; Element::of(\n            'log',\n            null,\n            $entries,\n        ))\n        -&gt;toSequence()\n        -&gt;toIdentity()\n        -&gt;map(static fn(Sequence $log) =&gt; Document::of(\n            Document\\Version::of(1, 0)\n            Maybe::nothing(),\n            Maybe::just(Document\\Encoding::of('utf-8')),\n            $log,\n        ))\n        -&gt;unwrap()\n        -&gt;asContent();\n}\n</code></pre> <p>If the input is a lazy <code>Sequence</code> then a call to <code>toIdentity</code> will create a lazy <code>Identity</code> and a call to <code>toSequence</code> will create a lazy <code>Sequence</code> (because the identity itself is lazy), thus the whole operation is lazy. On the other hand if the input is an in memory <code>Sequence</code> then the whole operation will be as well.</p> <p>In some sense the implementation of the function adapts itself to the need of its caller.</p> <p>The following packages have already been updated to allow this design:</p> <ul> <li><code>innmind/amqp</code></li> <li><code>innmind/encoding</code></li> <li><code>innmind/html</code></li> <li><code>innmind/xml</code></li> </ul> Going further <p>The examples above use the <code>innmind/xml</code> package. If you're not familiar with it it may be difficult to understand what's really happening. Let's break it down!</p> <p>The initial implementation with only <code>Sequence</code>s would look like this:</p> <pre><code>use Innmind\\Filesystem\\File\\Content;\nuse Innmind\\Immutable\\{\n    Sequence,\n    Str,\n};\n\n/**\n * @param Sequence&lt;string&gt; $entries\n */\nfunction build(Sequence $entries): Content\n{\n    $xml = Sequence::of('&lt;?xml version=\"1.0\"?&gt;')-&gt;append(\n        Sequence::of('&lt;log&gt;')\n            -&gt;append(\n                Sequence::of('&lt;entries&gt;')\n                    -&gt;append(\n                        $entries\n                            -&gt;map(static fn(string $entry) =&gt; \\sprintf(\n                                '&lt;entry&gt;%s&lt;/entry&gt;'\n                                $entry,\n                            ))\n                            -&gt;map(static fn(string $line) =&gt; '    '.$line),\n                    )\n                    -&gt;add('&lt;/entries&gt;')\n                    -&gt;map(static fn(string $line) =&gt; '    '.$line),\n            )\n            -&gt;add('&lt;/log&gt;'),\n    );\n\n    return Content::ofLines(\n        $xml\n            -&gt;map(Str::of(...))\n            -&gt;map(Content\\Line::of(...)),\n    );\n}\n</code></pre> <p>Before <code>innmind/immutable</code> <code>5.7</code> this is the best we could do. <code>5.7</code> introduced the <code>Sequence::prepend()</code> method.</p> <pre><code>function build(Sequence $entries): Content\n{\n    $xml = Sequence::of('&lt;?xml version=\"1.0\"?&gt;')-&gt;append(\n        Sequence::of('&lt;log&gt;')\n            -&gt;append(\n                $entries\n                    -&gt;map(static fn(string $entry) =&gt; \\sprintf(\n                        '&lt;entry&gt;%s&lt;/entry&gt;'\n                        $entry,\n                    ))\n                    -&gt;map(static fn(string $line) =&gt; '    '.$line)\n                    -&gt;prepend(Sequence::of('&lt;entries&gt;')),\n                    -&gt;add('&lt;/entries&gt;'),\n                    -&gt;map(static fn(string $line) =&gt; '    '.$line),\n            )\n            -&gt;add('&lt;/log&gt;'),\n    );\n\n    return Content::ofLines(\n        $xml\n            -&gt;map(Str::of(...))\n            -&gt;map(Content\\Line::of(...)),\n    );\n}\n</code></pre> <p><code>prepend</code> allows us to remove one level of nesting, but we still have the top <code>Sequence</code> that only works in memory.</p> <p>To fix it is to use <code>prepend</code> once more:</p> <pre><code>function build(Sequence $entries): Content\n{\n    $xml = $entries\n        -&gt;map(static fn(string $entry) =&gt; \\sprintf(\n            '&lt;entry&gt;%s&lt;/entry&gt;'\n            $entry,\n        ))\n        -&gt;map(static fn(string $line) =&gt; '    '.$line)\n        -&gt;prepend(Sequence::of('&lt;entries&gt;'))\n        -&gt;add('&lt;/entries&gt;')\n        -&gt;map(static fn(string $line) =&gt; '    '.$line)\n        -&gt;prepend(Sequence::of('&lt;log&gt;'))\n        -&gt;add('&lt;/log&gt;')\n        -&gt;prepend(Sequence::of('&lt;?xml version=\"1.0\"?&gt;'));\n\n    return Content::ofLines(\n        $xml\n            -&gt;map(Str::of(...))\n            -&gt;map(Content\\Line::of(...)),\n    );\n}\n</code></pre> <p>As a single pipeline this may be difficult to read, but we can break it up like this without changing what's happening:</p> <pre><code>function build(Sequence $entries): Content\n{\n    $entries = $entries-&gt;map(static fn(string $entry) =&gt; \\sprintf(\n        '&lt;entry&gt;%s&lt;/entry&gt;'\n        $entry,\n    ));\n    $entriesTag = $entries\n        -&gt;map(static fn(string $line) =&gt; '    '.$line)\n        -&gt;prepend(Sequence::of('&lt;entries&gt;'))\n        -&gt;add('&lt;/entries&gt;');\n    $log = $entriesTag\n        -&gt;map(static fn(string $line) =&gt; '    '.$line)\n        -&gt;prepend(Sequence::of('&lt;log&gt;'))\n        -&gt;add('&lt;/log&gt;');\n    $xml = $log-&gt;prepend(Sequence::of('&lt;?xml version=\"1.0\"?&gt;'));\n\n    return Content::ofLines(\n        $xml\n            -&gt;map(Str::of(...))\n            -&gt;map(Content\\Line::of(...)),\n    );\n}\n</code></pre> <p>As you may have noticed in this section we didn't have to use <code>Identity</code>. That's because we didn't have to wrap each <code>Sequence</code> in another object, it's this kind of wrappers that prevent direct composition of the <code>Sequence</code>s.</p> <p>If you're familiar with PHP the imperative way you may think all this is overengineered. You could write something like this and call it a day:</p> <pre><code>/**\n * @param iterable&lt;string&gt; $entries\n * @return iterable&lt;string&gt;\n */\nfunction build(iterable $entries): iterable\n{\n    yield '&lt;?xml version=\"1.0\"?&gt;';\n    yield '&lt;log&gt;';\n    yield '    &lt;entries&gt;';\n\n    foreach ($entries as $entry) {\n        yield \\sprintf(\n            '        &lt;entry&gt;%s&lt;/entry&gt;',\n            $entry,\n        );\n    }\n\n    yield '    &lt;/entries&gt;';\n    yield '&lt;/log&gt;';\n}\n</code></pre> <p>At first glance this is simpler and easier to read. But this brings numerous problems:</p> <ul> <li>the whole program has to use generators</li> <li>if not foreseen this will require everything to be rewritten with generators</li> <li>pseudo-type <code>iterable</code> let you think you can reuse the collection which may not be the case</li> <li>it forces a caller to be aware of the implementation</li> <li>someone using an <code>iterator_to_array</code> on the output of <code>build</code> may result in an out of memory error<ul> <li>this can be easily overlooked when reviewing the code</li> </ul> </li> <li>it loses the ability to run asynchronously</li> <li>and I'm sure more can be found...</li> </ul>"},{"location":"blog/2024/06/new-documentation-websites/","title":"New documentation websites","text":"<p>This documentation website intends to guide you through the different packages of this ecosystem and how to start using them.</p> <p>However, advance usage documentation of each package will still reside in their repositories. This helps keep the documentation up to date.</p> <p>Historically these documentations were simple markdown files alongside the code. From now on they'll be available as a website thanks to Material for MKDocs.</p> <p>The following documentations are already available:</p> <ul> <li><code>innmind/framework</code></li> <li><code>innmind/operating-system</code></li> <li><code>innmind/filesystem</code></li> <li><code>innmind/immutable</code></li> <li><code>innmind/black-box</code></li> </ul> <p>More should come in the future.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>In this chapter you'll learn all the basic information to create simple scripts to handle data up to distributed programs.</p> <p>Unless specified, the code exposed is accessible through the <code>foundation</code> package.</p> <pre><code>composer require innmind/foundation '~1.10'\n</code></pre> <p>Note</p> <p>For advanced usage of a particular package you should head to the package documentation.</p>"},{"location":"getting-started/app/cli/","title":"CLI","text":"<p>This package allows you to build scripts in a more structured way.</p>"},{"location":"getting-started/app/cli/#usage","title":"Usage","text":"cli.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'path/to/composer/autoload.php';\n\nuse Innmind\\CLI\\{\n    Main,\n    Environment,\n};\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\Immutable\\Attempt;\n\nnew class extends Main {\n    protected function main(Environment $env, OperatingSystem $os): Attempt\n    {\n        return $env-&gt;output(Str::of(\"Hello world\\n\"));\n    }\n};\n</code></pre> <p>If you run <code>php cli.php</code> in your terminal it will print <code>Hello world</code>.</p> <p>You should already be familiar with the <code>$os</code> variable by now, if not go the dedicated chapter.</p> <p>The <code>$env</code> variable is the abstraction to deal with everything inputed in your script and every output that comes out. It behaves like an immutable object, meaning you must always use the new instance returned by its methods.</p> <p>To change the returned exit code you can do <code>$env-&gt;exit(1)</code>.</p> <p>If you only have one action in your script you can do everything in the <code>main</code> method. But if you want to expose multiple commands you can do:</p> cli.php<pre><code>use Innmind\\CLI\\{\n    Commands,\n    Console,\n    Command,\n    Command\\Usage,\n};\nuse Innmind\\Immutable\\Attempt;\n\nnew class extends Main {\n    protected function main(Environment $env, OperatingSystem $os): Environment\n    {\n        $commands = Commands::of(\n            new class implements Command {\n                public function __invoke(Console $console): Attempt\n                {\n                    return $console-&gt;output(\n                        Str::of('Hello ')-&gt;append(\n                            $console-&gt;arguments()-&gt;get('name'),\n                        ),\n                    );\n                }\n\n                public function usage(): Usage\n                {\n                    return Usage::parse('greet name');\n                }\n            },\n            new class implements Command {\n                public function __invoke(Console $console): Attempt\n                {\n                    return $console-&gt;output(\n                        Str::of($console-&gt;arguments()-&gt;get('name'))\n                            -&gt;toUpper()\n                            -&gt;prepend('Hello '),\n                    );\n                }\n\n                public function usage(): Usage\n                {\n                    return Usage::parse('shout name');\n                }\n            },\n        );\n\n        return $commands($env);\n    }\n};\n</code></pre> <p>If you run <code>php cli.php greet Jane</code> it will output <code>Hello Jane</code> and if you run <code>php cli.php shout John</code> it will output <code>Hello JOHN</code>.</p> Info <p>For simplicity this example use anonymous classes but you can use any class as long as it implements <code>Command</code>.</p>"},{"location":"getting-started/app/cli/#advanced-usage","title":"Advanced usage","text":"<p>Full documentation available here.</p>"},{"location":"getting-started/app/http/","title":"HTTP","text":"<p>This package allows to build simple HTTP applications by representing requests and responses via objects.</p>"},{"location":"getting-started/app/http/#usage","title":"Usage","text":"index.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'path/to/composer/autoload.php';\n\nuse Innmind\\HttpServer\\Main;\nuse Innmind\\Http\\{\n    ServerRequest,\n    Response,\n};\nuse Innmind\\Filesystem\\File\\Content;\n\nnew class extends Main {\n    protected function main(ServerRequest $request): Response\n    {\n        return Response::of(\n            Response\\StatusCode::ok,\n            $request-&gt;protocolVersion(),\n            null,\n            Content::ofString('Hello world'),\n        );\n    }\n}\n</code></pre> <p>If you run the PHP server in the directory of this file via <code>php -S localhost:8080</code> and run <code>curl http://localhost:8080/</code> it will print <code>Hello world</code>.</p> Note <p>You can expose this script via any HTTP server that supports PHP.</p> <p>As you can see the response body is a file content, meaning it accepts any file content.</p> index.php<pre><code>use Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\Filesystem\\{\n    File,\n    Name,\n};\nuse Innmind\\Http\\{\n    Headers,\n    Header\\ContentType,\n};\nuse Innmind\\MediaType\\MediaType;\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Predicate\\Instance;\n\nnew class extends Main {\n    private OperatingSystem $os;\n\n    protected function preload(OperatingSystem $os): void\n    {\n        $this-&gt;os = $os;\n    }\n\n    protected function main(ServerRequest $request): Response\n    {\n        return Response::of(\n            Response\\StatusCode::ok,\n            $request-&gt;protocolVersion(),\n            Headers::of(\n                ContentType::of(new MediaType('image', 'png')),\n            ),\n            $this\n                -&gt;os\n                -&gt;filesystem()\n                -&gt;mount(Path::of('images/'))\n                -&gt;unwrap()\n                -&gt;get(Name::of('some-image.png'))\n                -&gt;keep(Instance::of(File::class))\n                -&gt;match(\n                    static fn(File $file) =&gt; $file-&gt;content(),\n                    static fn() =&gt; throw new \\RuntimeException(),\n                ),\n        );\n    }\n}\n</code></pre> <p>This example will send back the image at <code>images/some-image.png</code>. If the image is not found then it will throw an exception.</p> Note <p>The <code>main</code> function will catch all thrown exceptions and will return an empty <code>500</code> response. This is done to make sure no stack trace is ever shown to a user.</p> <p>During development if you want to see the exception you can catch all exceptions yourself and use <code>filp/whoops</code> to render it. Or you can use Innmind's framework and its profiler.</p> <p>For a very simple app this is enough, you can even do some routing manually by analyzing <code>$request-&gt;url()</code>. For any more than that you should start looking at the framework.</p>"},{"location":"getting-started/concurrency/","title":"Concurrency","text":"<p>Concurrency is about executing multiple parts of a program in way to waste as little time as possible. There is 2 ways possible to achieve this:</p> <ul> <li>asynchronicity</li> <li>parallelism</li> </ul> <p>Asynchronous code means there are at all times only one part of a program that's executed. But each part of the program advances one after the other in the same process. This mode is useful when your program is I/O bound, for example if a part of your program makes an HTTP call then another part can be executed while you wait for the response. However if your program is CPU bound then this mode has no usefulness.</p> <p>Parallel code means that multiple processes will be executed at the same time. Each process will be spread across the cores available on your CPU. This mode is useful when your program is CPU bound. But it comes with the disadvantage of coordinating the results of each process (when needed).</p> <p>Innmind offers solutions for both needs.</p>"},{"location":"getting-started/concurrency/async/","title":"Asynchronous code","text":"<p>Since Innmind offers to access all I/O operations through the operating system abstraction, it can easily execute these operations asynchronously.</p>"},{"location":"getting-started/concurrency/async/#usage","title":"Usage","text":"<p>Async works a bit like a reduce operation. The reducer function allows to launch tasks and react to their results. Both the reducer and tasks are run asynchronously.</p> ScriptCarried valueReducerMyTask <pre><code>use Innmind\\Async\\Scheduler;\nuse Innmind\\Http\\Response;\nuse Innmind\\Immutable\\Sequence;\n\n$responses = Scheduler::of($os)\n    -&gt;sink(Carried::new())\n    -&gt;with(new Reducer);\n$responses; // instance of Sequence&lt;?Response&gt;\n</code></pre> <p>Like in a real reduce operation you need a carried value that will be passed to the reducer every time it's called.</p> <p>Here we use a <code>Carried</code> class but you can use any type you want.</p> <pre><code>use Innmind\\Http\\Response;\nuse Innmind\\Immutable\\Sequence;\n\nfinal readonly class Carried\n{\n    /** @var Sequence&lt;?Response&gt; */\n    private function __construct(\n        private bool $tasksLaucnhed,\n        private Sequence $responses,\n    ) {}\n\n    public static function new(): self\n    {\n        return new self(false, Sequence::of());\n    }\n\n    public function tasksLaunched(): self\n    {\n        return new self(true, $this-&gt;responses);\n    }\n\n    public function needsToLaunchTasks(): bool\n    {\n        return !$this-&gt;tasksLaunched;\n    }\n\n    public function got(?Response $response): self\n    {\n        return new self(\n            $this-&gt;tasksLaunched,\n            $this-&gt;responses-&gt;add($response),\n        );\n    }\n\n    /** @return Sequence&lt;?Response&gt; */\n    public function responses(): Sequence\n    {\n        return $this-&gt;responses;\n    }\n}\n</code></pre> <p>To avoid unexpected side effects you should always use an immutable value for the carried value.</p> <pre><code>use Innmind\\Async\\Scope\\Continuation;\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\Http\\Response;\nuse Innmind\\Immutable\\Sequence;\n\nfinal class Reducer\n{\n    /**\n     * @param Continuation&lt;Carried&gt; $continuation\n     * @param Sequence&lt;mixed&gt; $results\n     *\n     * @return Continuation&lt;Carried&gt;\n     */\n    public function __invoke(\n        Carried $carried,\n        OperatingSystem $os, #(1)\n        Continuation $continuation,\n        Sequence $results, #(2)\n    ): Continuation {\n        if ($carried-&gt;needsToLaunchTasks()) {\n            return $continuation\n                -&gt;carryWith($carried-&gt;tasksLaunched()) #(3)\n                -&gt;schedule(Sequence::of(\n                    static fn(OperatingSystem $os) =&gt; MyTask::of( #(4)\n                        $os,\n                        'https://github.com/'\n                    ),\n                    static fn(OperatingSystem $os) =&gt; MyTask::of(\n                        $os,\n                        'https://gitlab.com/'\n                    ),\n                ));\n        }\n\n        $carried = $results-&gt;reduce(\n            $carried,\n            static fn(\n                Carried $carried,\n                ?Response $response\n            ) =&gt; $carried-&gt;got($response),\n        );\n\n        if ($carried-&gt;responses()-&gt;size() === 2) {\n            return $continuation\n                -&gt;carryWith($carried)\n                -&gt;finish(); #(5)\n        }\n\n        return $continuation\n            -&gt;carryWith($carried)\n            -&gt;wakeOnResult();\n    }\n}\n</code></pre> <ol> <li>This <code>$os</code> variable is a new instance built by Async and runs asynchronously.</li> <li>This will contain the values returned by the tasks as soon as available.</li> <li>We flip the flag in order to not launch the tasks each time the reducer is called.</li> <li>The <code>$os</code> variable is a dedicated new instance for each task.</li> <li>This tells Async to stop calling the reducer and return the carried value.</li> </ol> <p>This <code>__invoke</code> method will be called once when starting the runner and then each time a task finishes.</p> <p>The flag to know if the tasks have been launched is stored in the carried value, but since we're in an object it could be placed as a property. This is done so you can better differentiate the carried values from the <code>$results</code> in this example.</p> <pre><code>use Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\Http\\{\n    Request,\n    Response,\n    Method,\n    ProtocolVersion,\n};\nuse Innmind\\Url\\Url;\n\nfinal class MyTask {\n    public static function of(\n        OperatingSystem $os,\n        string $url,\n    ): ?Response {\n        return $os\n            -&gt;remote()\n            -&gt;http()(Request::of(\n                Url::of($url),\n                Method::get,\n                ProtocolVersion::v11,\n            ))\n            -&gt;match(\n                static fn(Success $success) =&gt; $success-&gt;response(),\n                static fn() =&gt; null,\n            );\n    }\n}\n</code></pre>"},{"location":"getting-started/concurrency/async/#advantages","title":"Advantages","text":"<p>The first big advantage of this design is that your task is completely unaware that it is run asynchronously. It all depends on the <code>$os</code> variable injected (1). This means that you can easily experiment a piece of your program in an async context by what code calls it, your program logic itself doesn't have to change!</p> <ol> <li>If it comes from Async it's async otherwise it's sync.</li> </ol> <p>The side effect of this is that you can test your code synchronously even though it's run asynchronously.</p> <p>The other advantage is that since all state is local you can compose async code inside sync code transparently. You can't affect a global state since there is none.</p>"},{"location":"getting-started/concurrency/async/#limitations","title":"Limitations","text":"<ul> <li>HTTP calls are currently done via <code>cURL</code> and uses micro sleeps instead of watching sockets</li> <li>SQL queries are still run synchronously for now</li> <li>It seems there is a limit of 100k concurrent tasks before performance degradation</li> </ul> <p>Most of these limitations are planned to be fixed in the future.</p> <p>You may not want to use this in production just yet, or at least not for mission critical code.</p>"},{"location":"getting-started/concurrency/distributed/","title":"Distributed","text":"<p>Innmind intends to provide a way to build distributed programs with the same philosophy seen so far.</p> <p>This way you'll be able to move to a distributed program with little effort.</p>"},{"location":"getting-started/concurrency/distributed/#actor-model","title":"Actor Model","text":"<p>The Actor Model is a way to build concurrent programs. It's built arount 3 concepts:</p> <ul> <li>an Actor is a compute unit that handle state</li> <li>an Actor can create actors</li> <li>an Actor can send/receive messages</li> </ul> <p>An actor can only receive one message at a time, meaning there's no concurrency on a single actor. This simplify drastically the complexity of handling state and eliminate data races.</p> <p>The concurrency as a whole is handled by the tree of actors that spread the work.</p> <p>You can think of this model as a queuing system that dynamically create new queues.</p> <p>But because having one process per actor would be too expensive in resources, it's required to be able to run multiple actors asynchronously inside a single process. Hence all the tools you've seen previously.</p>"},{"location":"getting-started/concurrency/distributed/#work-in-progress","title":"Work in progress","text":"<p>The implementation of this model is still underway at <code>innmind/actors</code>.</p> <p>There's been quite a gap in activity on this repository because early work on the implementation revealed that the use of exceptions was untenable for the system stability.</p> <p>This is what motivated the move to the monadic approach across all Innmind packages.</p>"},{"location":"getting-started/concurrency/http/","title":"HTTP calls","text":"<p>Traditionnaly the HTTP requests in PHP programs are synchronous for the sake of simplicity as PHP is single threaded. But this is wasteful when multiple requests could be sent at the same time.</p> <p>Innmind's HTTP client allows to move from synchronous calls to concurrent ones very easily.</p>"},{"location":"getting-started/concurrency/http/#example","title":"Example","text":"<p>Imagine you want to fetch 2 pages, this would be the synchronous code:</p> <pre><code>use Innmind\\HttpTransport\\Success;\nuse Innmind\\Http\\{\n    Request,\n    Method,\n    ProtocolVersion,\n};\nuse Innmind\\Url\\Url;\n\n$http = $os-&gt;remote()-&gt;http();\n$github = $http(Request::of(\n    Url::of('https://github.com'),\n    Method::get,\n    ProtocolVersion::v11,\n));\n$github-&gt;match(\n    static fn(Success $success) =&gt; doStuff($success-&gt;response()),\n    static fn() =&gt; failedToFetch(),\n);\n$gitlab = $http(Request::of(\n    Url::of('https://gitlab.com'),\n    Method::get,\n    ProtocolVersion::v11,\n));\n$gitlab-&gt;match(\n    static fn(Success $success) =&gt; doStuff($success-&gt;response()),\n    static fn() =&gt; failedToFetch(),\n);\n</code></pre> <p>Remember that the value returned by <code>$http</code> calls is an <code>Either</code>. More precisely it uses a deferred <code>Either</code>, meaning that the value it represents will be evaluated when you try to extract the value via the <code>match</code> method.</p> <p>This means that to make the calls concurrent you only need to move all the <code>match</code> calls after asking to make requests:</p> <pre><code>$http = $os-&gt;remote()-&gt;http();\n$github = $http(Request::of(\n    Url::of('https://github.com'),\n    Method::get,\n    ProtocolVersion::v11,\n));\n$gitlab = $http(Request::of(\n    Url::of('https://gitlab.com'),\n    Method::get,\n    ProtocolVersion::v11,\n));\n$github-&gt;match(\n    static fn(Success $success) =&gt; doStuff($success-&gt;response()),\n    static fn() =&gt; failedToFetch(),\n);\n$gitlab-&gt;match(\n    static fn(Success $success) =&gt; doStuff($success-&gt;response()),\n    static fn() =&gt; failedToFetch(),\n);\n</code></pre> <p>This way the HTTP client will execute all the requests planned before the first <code>match</code> is called.</p>"},{"location":"getting-started/concurrency/http/#tips","title":"Tips","text":""},{"location":"getting-started/concurrency/http/#unsent-requests","title":"Unsent requests","text":"<p>Remember to always keep a reference to a returned <code>Either</code> before calling a <code>match</code> method otherwise the non referenced request won't be sent. While this may seem tedious this opens a feature that may be very useful in certain cases.</p> <p>This way you can plan a bunch of requests and afterward based on some logic unplan some requests by de-referencing the <code>Either</code>s before calling a <code>match</code> method.</p> <p>This allows better flexibility in the way you can decouple your logic.</p>"},{"location":"getting-started/concurrency/http/#max-concurrency","title":"Max concurrency","text":"<p>By default the client will send all planned requests at once. But this can be problematic if you plan too many requests, the underlying <code>cURL</code> implementation may return some errors.</p> <p>You can configure the max concurrency at the start of your program and leave your business logic as is. You can do it this way:</p> Operating SystemFrameworkCLI appHTTP app <pre><code>use Innmind\\OperatingSystem\\Config;\nuse Innmind\\HttpTransport\\Curl;\n\n$os = $os-&gt;map(\n    static fn($config) =&gt; $config-&gt;useHttpTransport(\n        Curl::of(\n            $os-&gt;clock(),\n            $config-&gt;io(),\n        )-&gt;maxConcurrency(20),\n    ),\n);\n\n// rest of your script\n</code></pre> <pre><code>use Innmind\\Framework\\{\n    Main\\Cli,\n    Application,\n};\nuse Innmind\\OperatingSystem\\Config;\nuse Innmind\\HttpTransport\\Curl;\n\n$config = Config::of();\n$config = $config-&gt;useHttpTransport(\n    Curl::of(\n        $config-&gt;clock(),\n        $config-&gt;io(),\n    )-&gt;maxConcurrency(20),\n);\n\nnew class($config) extends Cli {\n    protected function configure(Application $app): Application\n    {\n        // configure your app here\n        return $app;\n    }\n}\n</code></pre> <p>Here we use the <code>Cli</code> entrypoint but it works the same way for the <code>Http</code> ones.</p> <pre><code>use Innmind\\CLI\\{\n    Main,\n    Environment,\n};\nuse Innmind\\OperatingSystem\\{\n    OperatingSystem,\n    Config,\n};\nuse Innmind\\HttpTransport\\Curl;\n\n$config = Config::of();\n$config = $config-&gt;useHttpTransport(\n    Curl::of(\n        $config-&gt;clock(),\n        $config-&gt;io(),\n    )-&gt;maxConcurrency(20),\n);\n\nnew class($config) extends Main {\n    protected function main(Environment $env, OperatingSystem $os): Environment\n    {\n        // your code here\n        return $env;\n    }\n};\n</code></pre> <p>Related chapter</p> <pre><code>use Innmind\\HttpServer\\Main;\nuse Innmind\\Http\\{\n    ServerRequest,\n    Response,\n};\nuse Innmind\\OperatingSystem\\Config;\nuse Innmind\\HttpTransport\\Curl;\n\n$config = Config::of();\n$config = $config-&gt;useHttpTransport(\n    Curl::of(\n        $config-&gt;clock(),\n        $config-&gt;io(),\n    )-&gt;maxConcurrency(20),\n);\n\nnew class($config) extends Main {\n    protected function main(ServerRequest $request): Response\n    {\n        // your code here\n        return Response::of(\n            Response\\StatusCode::ok,\n            $request-&gt;protocolVersion(),\n        );\n    }\n};\n</code></pre> <p>Related chapter</p> <p>The examples here use a maximum of <code>20</code> but you should adapt it to the needs of your program.</p>"},{"location":"getting-started/concurrency/http/#limits","title":"Limits","text":"<p>When calling a <code>match</code> method it will wait for all planned request to finish before giving you access to your request response.</p> <p>This means that you can't react as soon as a response is accessible. Your program can still stay idle for some time.</p> <p>If you need better reaction timing you should head to the asynchronous chapter.</p>"},{"location":"getting-started/concurrency/ipc/","title":"Inter Process Communication","text":"<p>When your program runs across multiple processes you may want to communicate between them to update some state.</p> <p>Innmind IPC use unix sockets to send messages between processes.</p>"},{"location":"getting-started/concurrency/ipc/#installation","title":"Installation","text":"<pre><code>composer require innmind/ipc:~4.4\n</code></pre>"},{"location":"getting-started/concurrency/ipc/#usage","title":"Usage","text":"ServerClient <pre><code>use Innmind\\IPC\\{\n    Factory,\n    Process\\Name,\n    Message,\n    Continuation,\n};\n\n$ipc = Factory::of($os);\n$serve = $ipc-&gt;listen(Name::of('server-name'));\n$counter = $serve(\n    0, #(1)\n    static function(\n        Message $message,\n        Continuation $continuation,\n        int $counter, #(2)\n    ): Continuation {\n        if ($counter === 42) {\n            return $continuation-&gt;stop($counter);\n        }\n\n        return $continuation-&gt;respond(\n            $counter + 1, #(3)\n            Message\\Generic::of('text/plain', 'pong'),\n        );\n    },\n)-&gt;match(\n    static fn(int $counter) =&gt; $counter,\n    static fn() =&gt; throw new \\RuntimeException('Unable to start the server'),\n);\n</code></pre> <ol> <li>This is the initial carried value.</li> <li>This is the carried value between every call of the function.</li> <li>This updates the carried value for the next message.</li> </ol> <p>The server behaves like a reduce operation, with a carried value and a function that's called every time a client sends a message. The carried value can be of any type.</p> <p>In this case the server will stop after receiving <code>42</code> messages.</p> <p>The returned value is an <code>Either</code> with the carried value on the right side or an error on the left side if the server failed to start.</p> <pre><code>use Innmind\\IPC\\{\n    Factory,\n    Process,\n    Process\\Name,\n    Message,\n};\n\n$ipc = Factory::of($os);\n$ipc\n    -&gt;wait(Name::of('server-name'))\n    -&gt;flatMap(fn(Process $process) =&gt; $process-&gt;send(Sequence::of(\n        Message\\Generic::of('text/plain', 'ping'),\n    )))\n    -&gt;flatMap(fn(Process $process) =&gt; $process-&gt;wait())\n    -&gt;match(\n        static fn(Message $message) =&gt; print(\n            'server responded '.$message-&gt;content()-&gt;toString(),\n        ),\n        static fn() =&gt; print('no response from the server'),\n    );\n</code></pre> <p>This will wait for the server to be up then it will send a <code>ping</code> message and wait for the server to respond. Then it will print <code>server responded pong</code> since the server always repond with this message unless it has stopped in the meantime.</p> Tip <p>If you want to immediately stop if the server is not up you can replace <code>$ipc-&gt;wait()</code> by <code>$ipc-&gt;get()</code>.</p>"},{"location":"getting-started/concurrency/queues/","title":"Queues","text":"<p>Innmind uses the AMQP protocol to build queues.</p> <p>You need to first install a server that implements this protocol (1). The most well known server is RabbitMQ.</p> <ol> <li>Only the version <code>0.9</code> is supported. (<code>1.0</code> is a completely different protocol)</li> </ol>"},{"location":"getting-started/concurrency/queues/#installation","title":"Installation","text":"<pre><code>composer require innmind/amqp '~6.0'\n</code></pre>"},{"location":"getting-started/concurrency/queues/#usage","title":"Usage","text":"<pre><code>use Innmind\\AMQP\\{\n    Factory,\n    Command\\DeclareExchange,\n    Command\\DeclareQueue,\n    Command\\Bind,\n    Model\\Exchange\\Type,\n};\nuse Innmind\\IO\\Sockets\\Internet\\Transport;\nuse Innmind\\TimeContinuum\\Period;\nuse Innmind\\Url\\Url;\n\n$client = Factory::of($os)\n    -&gt;build(\n        Transport::tcp(),\n        Url::of('amqp://guest:guest@localhost:5672/'),\n        Period::second(1), // heartbeat\n    )\n    -&gt;with(DeclareExchange::of('crawler', Type::direct))\n    -&gt;with(DeclareQueue::of('parser'))\n    -&gt;with(Bind::of('crawler', 'parser'));\n</code></pre> <p>This builds the basis of an AMQP client. As is it does nothing until it's run (more in a bit). The client is immutable and each call to <code>with</code> returns a new instance. In this case the <code>$client</code> will create an exchange named <code>crawler</code>, create a queue <code>parser</code> and will route every message published to <code>crawler</code> directly to <code>parser</code>.</p> Tip <p>You can head to the RabbitMQ tutorials to understand exchanges, queues and how to route your messages between the two.</p> <p>The first step is to publish messages before trying to consume them.</p> <pre><code>use Innmind\\AMPQ\\{\n    Model\\Basic\\Message,\n    Command\\Publish,\n    Failure,\n};\nuse Innmind\\Immutable\\Str;\n\n$message = Message::of(\n    Str::of('https://github.com');\n);\n$client\n    -&gt;with(Publish::one($message)-&gt;to('crawler'))\n    -&gt;run(null) #(1)\n    -&gt;unwrap();\n</code></pre> <ol> <li>For now don't worry about this <code>null</code>, just know that it's required.</li> </ol> <p>The client will execute anything only when the <code>run</code> method is called. In this case, because we reuse the client from above, it will create the exchange, the queue and bind them together and then publish one message that will end up in the queue.</p> <p>If everything works fine then it will return <code>null</code>. If any error occurs it will be throw an exception when calling <code>-&gt;unwrap()</code>.</p> Info <p>Using a client that always declare the the exchange and queues that it requires allows for a hot declaration of your infrastructure when you try to use the client. And if the exchanges, queues and bindings already exist it will silently continue to execute as the structure is the way you expect on the AMQP server.</p> <p>Then to consume the queue:</p> <pre><code>use Innmind\\AMQP\\{\n    Command\\Consume,\n    Model\\Basic\\Message,\n    Consumer\\Continuation,\n    Failure,\n};\n\n$count = $client\n    -&gt;with(Consume::of('parser')-&gt;handle(\n        static function(\n            int $count, #(1)\n            Message $message,\n            Continuation $continuation,\n        ): Continuation {\n            doStuff($message);\n\n            if ($count === 42) {\n                return $continuation-&gt;cancel($count);\n            }\n\n            return $continuation-&gt;continue($count + 1);\n        },\n    ))\n    -&gt;run(0) #(2)\n    -&gt;unwrap();\nvar_dump($count);\n</code></pre> <ol> <li>This argument is a carried value between each call of this function.</li> <li>This is the initial value passed to the function handling the messages.</li> </ol> <p>Here we reuse the client from the first example to make sure we indeed have a <code>parser</code> queue to work on. Then we consume the queue, meaning we'll wait for incoming messages and call the function when one arrives. This function behaves like a reduce operation where the initial value is <code>0</code> and is incremented each time a message is received. On the 43th message we'll handle the message and ask the client to stop consuming the queue.</p> <p>At this point the <code>run</code> method will return <code>42</code>.</p> <p>In this case the carried value is an <code>int</code> but you can use any type you want.</p> Tip <p>If you only need to pull one message from the queue you should use <code>Innmind\\AMQP\\Command\\Get</code> instead of <code>Consume</code>.</p> Tip <p>When consuming a queue by default the server will send as many messages as it can through the socket so there's no wait time when dealing the next message. However depending on the throughput of your program it can send too many messages in advance.</p> <p>To prevent network saturation you can use <code>Innmind\\AMQP\\Command\\Qos::of(100)</code> where <code>100</code> is the number of messages to send in advance. Add this command before adding the <code>Consume</code> command to the client.</p>"},{"location":"getting-started/framework/","title":"Framework","text":""},{"location":"getting-started/framework/#installation","title":"Installation","text":"<pre><code>composer require innmind/framework:~3.0\n</code></pre>"},{"location":"getting-started/framework/#concepts","title":"Concepts","text":"<p>The framework is defined by an entrypoint that specify the context in which the framework will be run. Each entrypoint exposes a <code>configure</code> method to configure an immutable <code>Application</code> object.</p> <p><code>Application</code> is the way to describe what your program can do. This is the same class no matter which entrypoint you choose. This allows you to switch the execution context without modifying any line of your code (1).</p> <ol> <li>For example moving from a synchronous HTTP context to an async HTTP server.</li> </ol> <p>The other advantage of this approach is that if your program is accessible from both HTTP and CLI it can be configured by the same code.</p>"},{"location":"getting-started/framework/#advanced-usage","title":"Advanced usage","text":"<p>The framework offers more than the features shown in this documentation, after reading the following chapters you should head to the package to learn the extent of its capabilities.</p>"},{"location":"getting-started/framework/cli/","title":"CLI","text":""},{"location":"getting-started/framework/cli/#usage","title":"Usage","text":"<p>The first step is to define the entrypoint:</p> bin/console<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'path/to/composer/autoload.php';\n\nuse Innmind\\Framework\\{\n    Main\\Cli,\n    Application,\n};\n\nnew class extends Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app;\n    }\n};\n</code></pre> <p>If you run <code>php bin/console</code> it will print <code>Hello world</code>.</p> <p>You can specify a command like so:</p> bin/console<pre><code>use Innmind\\CLI\\{\n    Console,\n    Command,\n    Command\\Usage,\n};\nuse Innmind\\Immutable\\{\n    Attempt,\n    Str,\n};\n\nnew class extends Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;command(\n            static fn() =&gt; new class implements Command {\n                public function __invoke(Console $console): Attempt\n                {\n                    return $console-&gt;output(\n                        Str::of('Hello ')-&gt;append(\n                            $console-&gt;arguments()-&gt;get('name'),\n                        ),\n                    );\n                }\n\n                public function usage(): Usage\n                {\n                    return Usage::of('greet')-&gt;argument('name');\n                }\n            },\n        );\n    }\n};\n</code></pre> <p>You can now do <code>php bin/console greet John</code> to print <code>Hello John</code>.</p> Info <p>This is the same classes used in a small CLI app. This allows you to easily migrate in case you app grows and you decide to use this framework.</p> Tip <p>The full definition of the function passed to the <code>command</code> method is:</p> <pre><code>use Innmind\\DI\\Container;\nuse Innmind\\CLI\\Command;\n\nstatic fn(Container $container): Command;\n</code></pre> <ul> <li><code>$container</code> is a service locator</li> </ul> <p>You can add as many commands as you wish by chaining calls to the <code>command</code> method.</p>"},{"location":"getting-started/framework/cli/#composition","title":"Composition","text":"<p>You can decorate all commands to execute some code on every command like this:</p> bin/console<pre><code>new class extends Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;mapCommand(\n                static fn(Command $command) =&gt; new class($command) implements Command {\n                    public function __construct(\n                        private Command $inner,\n                    ) {}\n\n                    public function __invoke(Console $console): Attempt\n                    {\n                        // you can execute code before here\n                        $console = ($this-&gt;inner)($console);\n                        // you can execute code after here\n\n                        return $console;\n                    }\n\n                    public function usage(): string\n                    {\n                        return $this-&gt;inner-&gt;usage();\n                    }\n                }\n            )\n            -&gt;command(/* ... */)\n            -&gt;command(/* ... */)\n            -&gt;command(/* ... */);\n        );\n    }\n};\n</code></pre> <p>For example you can use this approach to prevent commands to be run during deployments by checking if a file exists on the filesystem.</p>"},{"location":"getting-started/framework/extensions/","title":"Extensions","text":""},{"location":"getting-started/framework/extensions/#built-in","title":"Built-in","text":"<p>This framework comes with these middlewares:</p> <ul> <li><code>Innmind\\Framework\\Middleware\\Optional</code> to load a middleware only if the class exist, as seen in the profiler chapter</li> <li><code>Innmind\\Framework\\Middleware\\LoadDotEnv</code> to load a <code>.env</code> file and inject the values in the <code>Innmind\\Framework\\Environment</code> object</li> </ul>"},{"location":"getting-started/framework/extensions/#others","title":"Others","text":"<p>You can find other packages exposing middlewares via the virutal package <code>innmind/framework-middlewares</code> on Packagist.</p>"},{"location":"getting-started/framework/http/","title":"HTTP","text":""},{"location":"getting-started/framework/http/#usage","title":"Usage","text":"<p>The first step is to define the entrypoint:</p> public/index.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'path/to/composer/autoload.php';\n\nuse Innmind\\Framework\\{\n    Main\\Http,\n    Application,\n};\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app;\n    }\n};\n</code></pre> <p>You can expose this server via <code>cd public/ &amp;&amp; php -S localhost:8080</code>. If you run <code>curl http://localhost:8080/</code> it will return a <code>404</code> response which is the default behaviour when you didn't specify any route.</p> <p>You can define a route like this:</p> public/index.php<pre><code>use Innmind\\Framework\\Http\\Route;\nuse Innmind\\Http\\{\n    ServerRequest,\n    Response,\n};\nuse Innmind\\Filesystem\\File\\Content;\nuse Innmind\\Immutable\\Attempt;\n\nenum Services implements Service\n{\n    case hello;\n}\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;service(\n                Services::hello,\n                static fn() =&gt; static fn(ServerRequest $request) =&gt; Attempt::result(\n                    Response::of(\n                        Response\\StatusCode::ok,\n                        $request-&gt;protocolVersion(),\n                        null,\n                        Content::ofString('Hello world'),\n                    ),\n                ),\n            )\n            -&gt;route(Route::get(\n                '/',\n                Services::hello,\n            );\n    }\n};\n</code></pre> <p>Now <code>curl http://localhost:8080/</code> will return a <code>200</code> response with the content <code>Hello world</code>.</p> <p>You can specify placeholders in your routes like this:</p> public/index.php<pre><code>new class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;service(\n                Services::hello,\n                static fn() =&gt; static fn(ServerRequest $request, string $name) =&gt; Attempt::result(\n                    Response::of(\n                        Response\\StatusCode::ok,\n                        $request-&gt;protocolVersion(),\n                        null,\n                        Content::ofString(\"Hello $name\"),\n                    ),\n                ),\n            )\n            -&gt;route(Route::get(\n                '/greet/{name}',\n                Services::hello,\n            );\n    }\n};\n</code></pre> <p><code>curl http://localhost:8080/greet/Jane</code> will return <code>Hello Jane</code>.</p> <p>The route template is defined by the RFC6570. You can learn more about its implementation in this package.</p> Tip <p>The full definition of the function passed to the <code>route</code> method is:</p> <pre><code>use Innmind\\Router\\{\n    Component,\n    Pipe,\n};\nuse Innmind\\DI\\Container;\n\nstatic fn(\n    Pipe $pipe\n    Container $container,\n): Component;\n</code></pre> <ul> <li><code>$pipe</code> is a factory to help build routes</li> <li><code>$container</code> is a service locator</li> </ul>"},{"location":"getting-started/framework/http/#composition","title":"Composition","text":"<p>You can decorate all routes to execute some code on every route like this:</p> public/index.php<pre><code>new class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;mapRoute(\n                static fn(Component $route) =&gt; Component::of(static function(\n                    ServerRequest $request,\n                    mixed $input,\n                ) {\n                    // you can execute code before here\n\n                    return Attempt::result($input);\n                })\n                    -&gt;pipe($route)\n                    -&gt;pipe(Component::of(static function($request, $response) {\n                        // you can execute code after here\n\n                        return Attempt::result($response);\n                    })),\n            )\n            -&gt;route(/* ... */)\n            -&gt;route(/* ... */)\n            -&gt;route(/* ... */);\n        );\n    }\n};\n</code></pre> <p>For example you can use this approach to prevent routes to be run during deployments by checking if a file exists on the filesystem.</p>"},{"location":"getting-started/framework/http/#webserver","title":"Webserver","text":""},{"location":"getting-started/framework/http/#apache-nginx-caddy-etc","title":"Apache, Nginx, Caddy, etc...","text":"<p>In the example above we expose the program via a <code>public/</code> folder. You can expose this folder with any HTTP server you're familiar with.</p> <p>You'll need to enable url rewriting so all paths requested are redirected to the <code>index.php</code> file.</p>"},{"location":"getting-started/framework/http/#built-in","title":"Built-in","text":"<p>Instead of using the <code>Innmind\\Framework\\Main\\Http</code> entrypoint you can use <code>Innmind\\Framework\\Main\\Async\\Http</code>. Now the PHP file is a CLI program that will open the port <code>8080</code> by default on your machine.</p> <p>You can send it <code>curl</code> requests just as before. The difference is that your code now runs asynchronously (1).</p> <ol> <li>As long as you use the Operating System abstraction.</li> </ol> <p>This execution mode however is limited. For example it doesn't support multipart requests.</p> <p>You should use this as an experiment to see how your code behave asynchronously.</p>"},{"location":"getting-started/framework/middlewares/","title":"Middlewares","text":"<p>So far you've configured each kind of app directly in its entrypoint. This is fine for small apps that you don't unit test. But as your program grows you'll need to better structure it and test it.</p> <p>The way to organise the framework configuration is through middlewares. And it looks like that:</p> <pre><code>use Innmind\\Framework\\{\n    Application,\n    Middleware,\n};\n\nfinal class MyMiddleware implements Middleware\n{\n    public function __invoke(Application $app): Application\n    {\n        return $app\n            -&gt;command(/* as seen previously */)\n            -&gt;route(/* as seen previously */);\n    }\n}\n</code></pre> <p>In this method you can configure the <code>Application</code> the same way you would do in the entrypoint. And since the configuration api is the same no matter the entry point chosen (HTTP or CLI) you can declare both CLI commands and HTTP routes inside the same middleware.</p> <p>And to use it:</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Http,\n    Application,\n};\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;map(new MyMiddleware);\n    }\n};\n</code></pre> Info <p>The notation <code>$app-&gt;map($middleware)</code> is just an invertion of who calls who for better chaining methods. If you look at the implementation it does <code>$middleware($app)</code>.</p> <p>Since the middleware is a plain old PHP object, you can also add parameters to it.</p> <p>Let's say your program is a website that is accessible both in french and english. Instead of adding a parameter in every route and pass it around in every layer of your program you could do:</p> EntrypointMiddleware <pre><code>use Innmind\\Framework\\{\n    Main\\Http,\n    Application,\n};\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;map(new MyMiddleware('fr'))\n            -&gt;map(new MyMiddleware('en'));\n    }\n};\n</code></pre> <pre><code>final class MyMiddleware implements Middleware\n{\n    private string $language;\n\n    public function __construct(string $language)\n    {\n        $this-&gt;language = $language;\n    }\n\n    public function __invoke(Application $app): Application\n    {\n        return $app\n            -&gt;route(\"GET /{$this-&gt;language}\", /* index handler */)\n            -&gt;route(\"GET /{$this-&gt;language}/route1\", /* handler */)\n            -&gt;route(\"GET /{$this-&gt;language}/route2\", /* handler */)\n            -&gt;route(\"GET /{$this-&gt;language}/route/etc\", /* handler */);\n    }\n}\n</code></pre> Tip <p>And since you have access to the language at the configuration time you could even use different databases.</p> Middleware<code>Services</code> <pre><code>final class MyMiddleware implements Middleware\n{\n    private string $language;\n\n    public function __construct(string $language)\n    {\n        $this-&gt;language = $language;\n    }\n\n    public function __invoke(Application $app): Application\n    {\n        return $app\n            -&gt;service(\n                Services::database($this-&gt;language),\n                fn($_, $os) =&gt; $os\n                    -&gt;remote()\n                    -&gt;sql(Url::of(match ($this-&gt;language) {\n                        'en' =&gt; 'mysql://127.0.0.1:3306/website_en',\n                        'fr' =&gt; 'mysql://127.0.0.1:3306/website_fr',\n                    })),\n            )\n            -&gt;route(\n                \"GET /{$this-&gt;language}\",\n                function(\n                    $request,\n                    $variables,\n                    Container $get,\n                ) {\n                    $sql = $get(Services::database($this-&gt;language));\n                    $someData = $sql(/* some Query */);\n\n                    return Response::of(/* build response with $someData */);\n                }\n            );\n    }\n}\n</code></pre> <pre><code>enum Services\n{\n    case databaseEn;\n    case databaseFr;\n\n    public static function database(string $language): self\n    {\n        return match ($language) {\n            'en' =&gt; self::databaseEn,\n            'fr' =&gt; self::databaseFr,\n        };\n    }\n}\n</code></pre>"},{"location":"getting-started/framework/profiler/","title":"Profiler","text":"<p>Warning</p> <p>This section is not yet compatible with the latest major version of the framework.</p> <p>Innmind comes with an optional profiler to help you debug your program.</p> <p>It works for both HTTP (sync or async) and CLI programs.</p>"},{"location":"getting-started/framework/profiler/#installation","title":"Installation","text":"<pre><code>composer require --dev innmind/debug:~4.0\n</code></pre>"},{"location":"getting-started/framework/profiler/#usage","title":"Usage","text":"<pre><code>use Innmind\\Framework\\{\n    Application,\n    Main\\Http,\n    Middleware\\Optional,\n};\nuse Innmind\\Profiler\\Web\\Kernel as Profiler;\nuse Innmind\\Debug\\Kernel as Debug;\nuse Innmind\\Url\\Path;\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;map(Optional::of(\n                Debug::class,\n                static fn() =&gt; Debug::inApp()-&gt;operatingSystem(), #(1)\n            ))\n            -&gt;map(new MyMiddleware)\n            -&gt;map(Optional::of(\n                Profiler::class,\n                static fn() =&gt; Profiler::inApp(Path::of('var/profiler/')), #(2)\n            ))\n            -&gt;map(Optional::of(\n                Debug::class,\n                static fn() =&gt; Debug::inApp()-&gt;app(), #(3)\n            ));\n    }\n};\n</code></pre> <ol> <li>This will record every calls made to the Operating System.</li> <li>This exposes the profiler's HTTP routes. The path is where the profiles will be stored.</li> <li>This will record the incoming HTTP requests and CLI commands and their results.</li> </ol> <p>The <code>Optional</code> middleware will not call the underlying middleware if the class doesn't exist. This allows to automatically not declare the profiler in production, since it's a composer dev dependency.</p> <p>You can then access the profiler via <code>GET /_profiler/</code>. It will show the list of recorded profiles:</p> <p></p> <p> is successful,  is still running and  failed.</p> <p>This profiler's advantages is that you can see the profiles while it's being recorded. This means that you don't have to wait for a long CLI command to finish to see what happened.</p> <p>The other advantage is the way profiles are stored: in a human readable way. If your program does a lot of things (like hundreds of HTTP calls) you can browse the profile's folder and look around individual calls.</p> Screenshots HTTPExceptionApp graphEnvironmentProcessesRemote ProcessesRemote HTTP <p></p> <p></p> <p>You need to have graphviz installed to view this.</p> <p></p> <p>This is the object tree loaded to respond to a request/command.</p> <p>You need to have graphviz installed to view this.</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"getting-started/handling-data/","title":"Handling data","text":"<p>Handling data is an essential part of any program. Handling them simply and in a safe way can become difficult as a program becomes more complex.</p> <p>In this chapter you'll find the 3 most used data structures throughout Innmind.</p> <p>You'll learn how to them for simple cases and how they become indispensable as a program grows.</p>"},{"location":"getting-started/handling-data/#advanced-usage","title":"Advanced usage","text":"<p>Full documentation available here.</p>"},{"location":"getting-started/handling-data/either/","title":"Either","text":"<p>The <code>Either</code> monad always represents a value but it's either on a right side or left side.</p> <p>If you've understood <code>Maybe</code>, it's an <code>Either</code> with the <code>Maybe</code> value on the right side or <code>null</code> as the value on the left side.</p> <p>In essence: <pre><code>use Innmind\\Immutable\\Either;\n\n$right = Maybe::just(42);\n$left = Maybe::nothing();\n// becomes\n$right = Either::right(42);\n$left = Either::left(null);\n</code></pre></p> <p>It is usually used to express a value for a nominal case on the right side and the errors that may occur on the left side. This means that it replaces the use of <code>Exception</code>s.</p> <p>Each example will show how to use <code>Either</code> and the imperative equivalent in plain old PHP via <code>Exception</code>s.</p> Tip <p>This is because <code>Maybe</code> and <code>Either</code> are very similar that you can switch for one type to another via <code>$maybe-&gt;either()</code> (1) or <code>$either-&gt;maybe()</code> (2).</p> <ol> <li>then the left side is <code>null</code></li> <li>the left value is thrown away</li> </ol>"},{"location":"getting-started/handling-data/either/#usage","title":"Usage","text":"<p>Let's say you want to create a user from an email and the function must fail in case the email already exist. You could do:</p> InnmindImperative <pre><code>/**\n * @return Either&lt;EmailAlreadyUsed, User&gt;\n */\nfunction createUser(string $email, string $name): Either {\n    if (/* some condition to check if email is already known*/) {\n        return Either::left(new EmailAlreadyUsed);\n    }\n\n    /* code to insert the user in a db */\n    $user = new User($email, $name);\n\n    return Either::right($user);\n}\n\ncreateUser('foo@example.com', 'John Doe')-&gt;match(\n    static fn(User $user) =&gt; doStuff($user),\n    static fn(EmailAlreadyUsed $error) =&gt; doOtherStuff(),\n);\n</code></pre> <pre><code>/**\n * @throws EmailAlreadyUsed\n * @return User\n */\nfunction createUser(string $email, string $name): User {\n    if (/* some condition to check if email is already known*/) {\n        throw new EmailAlreadyUsed;\n    }\n\n    /* code to insert the user in a db */\n    $user = new User($email, $name);\n\n    return $user;\n}\n\ntry {\n    $user = createUser('foo@example.com', 'John Doe');\n    doStuff($user);\n} catch (EmailAlreadyUsed $e) {\n    doOtherStuff();\n}\n</code></pre> <p>Here we use a <code>string</code> to represent an email, instead we should use an object to abstract it to make sure the value is indeed an email.</p> InnmindImperative <pre><code>final class Email\n{\n    /**\n     * @return Either&lt;InvalidEmail, self&gt;\n     */\n    public static function of(string $value): Either\n    {\n        if (/* check value */) {\n            return Either::right(new self($value));\n        }\n\n        return Either::left(new InvalidEmail);\n    }\n}\n\nEmail::of('foo@example.com')\n    -&gt;flatMap(static fn(Email $email) =&gt; createUser($email, 'John Doe'))\n    -&gt;match(\n        static fn(User $user) =&gt; doStuff($user),\n        static fn(InvalidEmail | EmailAlreadyUsed $error) =&gt; doOtherStuff(),\n    );\n</code></pre> <pre><code>final class Email\n{\n    /**\n     * @throws InvalidEmail\n     * @return self\n     */\n    public static function of(string $value): self\n    {\n        if (/* check value */) {\n            return new self($value);\n        }\n\n        throw new InvalidEmail;\n    }\n}\n\ntry {\n    $email = Email::of('foo@example.com');\n    $user = createUser($email, 'John Doe');\n    doStuff($user);\n} catch (InvalidEmail | EmailAlreadyUsed $e) {\n    doOtherStuff();\n}\n</code></pre> <p>Both approaches seem very similar but there's a big advantage to <code>Either</code>: a static analysis tool understands the flow of errors and can tell you if when calling <code>match</code> you don't handle all possible error values. No tool can help you do the same with exceptions.</p> <p>Just like <code>Maybe</code> you can recover in case of an error via the <code>otherwise</code> method. For example in the case the email is already used, instead of failing we can decide to update the stored user.</p> InnmindImperative <pre><code>Email::of('foo@example.com')\n    -&gt;flatMap(\n        static fn(Email $email) =&gt; createUser($email, 'John Doe')-&gt;otherwise(\n            static fn(EmailAlreadyUsed $error) =&gt; updateUser($email, 'John Doe'),\n        ),\n    )\n    -&gt;match(\n        static fn(User $user) =&gt; doStuff($user),\n        static fn(InvalidEmail $error) =&gt; doOtherStuff(),\n    );\n</code></pre> <pre><code>try {\n    $email = Email::of('foo@example.com');\n\n    try {\n        $user = createUser($email, 'John Doe');\n    } catch (EmailAlreadyUsed $e) {\n        $user = updateUser($email, 'John Doe');\n    }\n\n    doStuff($user);\n} catch (InvalidEmail $e) {\n    doOtherStuff();\n}\n</code></pre> <p>In all examples you've seen the use of <code>flatMap</code> but you can also use the <code>map</code> to modify the value on the right side. And there's a <code>leftMap</code> to modify the value on the left side.</p>"},{"location":"getting-started/handling-data/either/#in-the-ecosystem","title":"In the ecosystem","text":"<p><code>Either</code> is used when an action may have multiple cases of errors that you should handle, such as HTTP calls or when working with queues.</p> <p>But the beauty is that if you don't want to deal with the different errors you can throw them away by converting the <code>Either</code> to a <code>Maybe</code> via <code>$either-&gt;maybe()</code>.</p> <p>Like <code>Maybe</code> and <code>Sequence</code> is has a deferred mode that allows to postpone some actions as you'll see in the concurrent HTTP calls chapter.</p>"},{"location":"getting-started/handling-data/maybe/","title":"Maybe","text":"<p>A <code>Maybe</code> monad represents the possible absence of a value.</p> <p>This is an equivalent of a nullable value, but a more faithful representation would be an <code>array</code> containing 0 or 1 value.</p> <p>In essence: <pre><code>use Innmind\\Immutable\\Maybe;\n\n$valueExist = 42;\n$valueDoesNotExist = null;\n// or\n$valueExist = [42];\n$valueDoesNotExist = [];\n// becomes\n$valueExist = Maybe::just(42);\n$valueDoesNotExist = Maybe::nothing();\n</code></pre></p> <p>Each example will show how to use <code>Maybe</code> and the imperative equivalent in plain old PHP (1).</p> <ol> <li>The nullable approach is used as it's the dominant approach in PHP programs.</li> </ol>"},{"location":"getting-started/handling-data/maybe/#usage","title":"Usage","text":"InnmindImperative <pre><code>/**\n * @return Maybe&lt;User&gt;\n */\nfunction getUser(int $id): Maybe {\n    return match ($id) {\n        42 =&gt; Maybe::just(new User),\n        default =&gt; Maybe::nothing(),\n    };\n}\n</code></pre> <pre><code>function getUser(int $id): ?User {\n    return match ($id) {\n        42 =&gt; new User,\n        default =&gt; null,\n    };\n}\n</code></pre> <p>In this function we represent the fact that they're may be not a <code>User</code> (1) for every id. To work with the user, if there's any, you would do:</p> <ol> <li>This is a fake class.</li> </ol> InnmindImperative <pre><code>getUser(42)-&gt;match(\n    static fn(User $user) =&gt; doStuff($user),\n    static fn() =&gt; userDoesntExist(),\n);\n</code></pre> <pre><code>match ($user = getUser(42)) {\n    null =&gt; userDoesntExist(),\n    default =&gt; doStuff($user),\n};\n</code></pre> <p>As you can see the 2 approaches are very similar for now.</p> <p>In this example the user is directly used as an argument to a function but we often want to extract some data before calling some function. A use case could be to extract the brother id out of this user (1) and call again our function.</p> <ol> <li>Via a method <code>function getBrotherId(): int</code>.</li> </ol> InnmindImperative <pre><code>getUser(42)\n    -&gt;map(static fn(User $user) =&gt; $user-&gt;getBrotherId())\n    -&gt;flatMap(static fn(int $id) =&gt; getUser($id))\n    -&gt;match(\n        static fn(User $brother) =&gt; doStuff($brother),\n        static fn() =&gt; brotherDoesNotExist(),\n    );\n</code></pre> <pre><code>$user = getUser(42);\n\nif (\\is_null($user)) {\n    brotherDoesNotExist();\n\n    return;\n}\n\n$brother = getUser($user-&gt;getBrotherId());\n\nif (\\is_null($brother)) {\n    brotherDoesNotExist();\n\n    return;\n}\n\ndoStuff($brother);\n</code></pre> <p>This example introduces the <code>map</code> and <code>flatMap</code> methods. They behave the same way as their <code>Sequence</code> counterpart.</p> <ul> <li><code>map</code> will apply the function in case the <code>Maybe</code> contains a value</li> <li> <p><code>flatMap</code> is similar to <code>map</code> except that the function passed to it must return a <code>Maybe</code>, instead of having the return type <code>Maybe&lt;Maybe&lt;User&gt;&gt;</code> (1) you'll have a <code>Maybe&lt;User&gt;</code></p> <ol> <li>as you would by using <code>map</code> instead of <code>flatMap</code></li> </ol> </li> </ul> <p>What this example shows is that with <code>Maybe</code> you only need to deal with the possible absence of the data when you extract it. While with the imperative style you need to deal with it each time you call a function.</p> <p>This becomes even more flagrant if the method that returns the brother id itself may not return a value (1). The signature becomes <code>function getBrotherId(): Maybe&lt;int&gt;</code>.</p> <ol> <li>as one may not have one</li> </ol> InnmindImperative <pre><code>getUser(42)\n    -&gt;flatMap(static fn(User $user) =&gt; $user-&gt;getBrotherId()) #(1)\n    -&gt;flatMap(static fn(int $id) =&gt; getUser($id))\n    -&gt;match(\n        static fn(User $brother) =&gt; doStuff($brother),\n        static fn() =&gt; brotherDoesNotExist(),\n    );\n</code></pre> <ol> <li>This is the only change, <code>map</code> is replaced by <code>flatMap</code> do deal with the possible absence.</li> </ol> <pre><code>$user = getUser(42);\n\nif (\\is_null($user)) {\n    brotherDoesNotExist();\n\n    return;\n}\n\n$brotherId = $user-&gt;getBrotherId();\n\nif (\\is_null($brotherId)) {\n    brotherDoesNotExist();\n\n    return;\n}\n\n$brother = getUser($brotherId);\n\nif (\\is_null($brother)) {\n    brotherDoesNotExist();\n\n    return;\n}\n\ndoStuff($brother);\n</code></pre> <p>So far we do nothing in case our user doesn't have a brother. But what if we want to check if he has a sister in case he doesn't have a brother ? <code>Maybe</code> has an expressive way to describe such case:</p> InnmindImperative <pre><code>getUser(42)\n    -&gt;flatMap(\n        static fn(User $user) =&gt; $user\n            -&gt;getBrotherId()\n            -&gt;otherwise(static fn() =&gt; $user-&gt;getSistserId()),\n    )\n    -&gt;flatMap(static fn(int $id) =&gt; getUser($id))\n    -&gt;match(\n        static fn(User $sibling) =&gt; doStuff($sibling),\n        static fn() =&gt; brotherDoesNotExist(),\n    );\n</code></pre> <pre><code>$user = getUser(42);\n\nif (\\is_null($user)) {\n    brotherDoesNotExist();\n\n    return;\n}\n\n$siblingId = $user-&gt;getBrotherId() ?? $user-&gt;getSisterId();\n\nif (\\is_null($siblingId)) {\n    brotherDoesNotExist();\n\n    return;\n}\n\n$sibling = getUser($siblingId);\n\nif (\\is_null($sibling)) {\n    brotherDoesNotExist();\n\n    return;\n}\n\ndoStuff($sibling);\n</code></pre>"},{"location":"getting-started/handling-data/maybe/#in-the-ecosystem","title":"In the ecosystem","text":"<p><code>Maybe</code> is used to express the abscence of data (1). The possible failure of an operation (2) is expressed with a similar monad called <code>Attempt</code>. It is expressed via <code>Attempt&lt;Innmind\\Immutable\\SideEffect&gt;</code>, meaning if it contains a <code>SideEffect</code> the operation as succeeded otherwise it failed.</p> <ol> <li>Such as the absence of a file on the filesystem or the absence of an entity from a storage.</li> <li>Such as failing to upload a file to an S3 bucket.</li> </ol> <p>It also has a deferred mode like <code>Sequence</code> that allows to not directly load in memory a value when you call <code>$sequence-&gt;get($index)</code>. The returned <code>Maybe</code> in this case will load the value when you call the <code>match</code> method.</p>"},{"location":"getting-started/handling-data/sequence/","title":"Sequence","text":"<p>A <code>Sequence</code> monad represents a succession of values. In plain old PHP this is an array where you don't specify any key.</p> <p>In essence: <pre><code>use Innmind\\Immutable\\Sequence;\n\n$values = ['foo', 'bar', 'baz'];\n// becomes\n$values = Sequence::of('foo', 'bar', 'baz');\n</code></pre></p> <p>Of course just holding to multiple values is not very useful in itself. You'll see below how to manipulate this list of values.</p> <p>Each example will show how to use the <code>Sequence</code> and how to do the same in plain old PHP in a declarative and imperative style. So you can better grasp what's happening.</p>"},{"location":"getting-started/handling-data/sequence/#pipelining","title":"Pipelining","text":"<p>When dealing with a list of values we tend to apply multiple logic to it in succession. The more steps to transform our values the more complex it becomes.</p> <p>The <code>Sequence</code> helps better break down each step.</p>"},{"location":"getting-started/handling-data/sequence/#transformations","title":"Transformations","text":"<p>If we reuse the example with the strings and we want to uppercase the first letter of each value we would do:</p> InnmindDeclarativeImperative <pre><code>$values = Sequence::of('foo', 'bar', 'baz')\n    -&gt;map(static fn(string $string) =&gt; \\ucfirst($string))\n    -&gt;toList();\n$values === ['Foo', 'Bar', 'Baz']; // returns true\n</code></pre> <pre><code>$values = \\array_map(\n    static fn(string $string) =&gt; \\ucfirst($string),\n    ['foo', 'bar', 'baz'],\n);\n$values === ['Foo', 'Bar', 'Baz']; // returns true\n</code></pre> <pre><code>$values = [];\n\nforeach (['foo', 'bar', 'baz'] as $string) {\n    $values[] = \\ucfirst($string);\n}\n\n$values === ['Foo', 'Bar', 'Baz']; // returns true\n</code></pre> <p>The <code>map</code> method returns a new object <code>Sequence</code> with all the values modified by the function passed as argument. And the original object returned by <code>Sequence::of()</code> is not altered, meaning you can reuse it safely to do other operations.</p> Tip <p>The notation <code>static fn(string $string) =&gt; \\ucfirst($string)</code> can be shortened to <code>\\ucfirst(...)</code>.</p> <p>With <code>map</code> the new object will contain the same number of values as the initial object. But some times for each value you want to return multiple values and in the end have an <code>array</code> with only one dimension.</p> <p>Let's take the example where each <code>string</code> represent a username and we want to retrieve their addresses:</p> InnmindDeclarativeImperative <pre><code>/**\n * @return Sequence&lt;string&gt;\n */\nfunction getAddresses(string $username): Sequence {\n    // this is a fake implementation\n    return Sequence::of(\n        \"$username address 1\",\n        \"$username address 2\",\n        \"$username address 3\",\n    );\n}\n\n$addresses = Sequence::of('foo', 'bar', 'baz')\n    -&gt;flatMap(static fn(string $username) =&gt; getAdresses($username))\n    -&gt;toList();\n$addresses === [\n    'foo address 1',\n    'foo address 2',\n    'foo address 3',\n    'bar address 1',\n    'bar address 2',\n    'bar address 3',\n    'baz address 1',\n    'baz address 2',\n    'baz address 3',\n]; // returns true\n</code></pre> <pre><code>/**\n * @return list&lt;string&gt;\n */\nfunction getAddresses(string $username): array {\n    // this is a fake implementation\n    return [\n        \"$username address 1\",\n        \"$username address 2\",\n        \"$username address 3\",\n    ];\n}\n\n$addressesPerUser = \\array_map(\n    static fn(string $username) =&gt; getAddresses($username),\n    ['foo', 'bar', 'baz'],\n);\n$addresses = \\array_merge(...$addressesPerUser);\n$addresses === [\n    'foo address 1',\n    'foo address 2',\n    'foo address 3',\n    'bar address 1',\n    'bar address 2',\n    'bar address 3',\n    'baz address 1',\n    'baz address 2',\n    'baz address 3',\n]; // returns true\n</code></pre> <pre><code>/**\n * @return list&lt;string&gt;\n */\nfunction getAddresses(string $username): array {\n    // this is a fake implementation\n    return [\n        \"$username address 1\",\n        \"$username address 2\",\n        \"$username address 3\",\n    ];\n}\n\n$addresses = [];\n\nforeach (['foo', 'bar', 'baz'] as $username) {\n    foreach (getAddresses($username) as $address) {\n        $addresses[] = $address;\n    }\n}\n\n$addresses === [\n    'foo address 1',\n    'foo address 2',\n    'foo address 3',\n    'bar address 1',\n    'bar address 2',\n    'bar address 3',\n    'baz address 1',\n    'baz address 2',\n    'baz address 3',\n]; // returns true\n</code></pre> <p>Here you can see that <code>flatMap</code> is a combination of <code>map</code> that would return the type <code>Sequence&lt;Sequence&lt;string&gt;&gt;</code> and then flattens it to obtain a <code>Sequence&lt;string&gt;</code>, hence the name <code>flatMap</code>.</p> <p>You can also already see that the <code>Sequence</code> is simpler to chain actions because there is no need to assign the intermediate values to a new variable. In plain old PHP you could also avoid the intermediate values by inlining the calls but you'll quickly end up with a code harder to read with a lot of indentation.</p> <p><code>map</code> and <code>flatMap</code> are the only 2 methods to apply a modification to a <code>Sequence</code>.</p>"},{"location":"getting-started/handling-data/sequence/#composition","title":"Composition","text":"<p>Since you'll not always have all the values known when creating a <code>Sequence</code>, you need to know how to add new values.</p> InnmindDeclarativeImperative <pre><code>$values = Sequence::of('foo')\n    -&gt;add('bar')\n    -&gt;add('baz')\n    -&gt;toList();\n$values = ['foo', 'bar', 'baz']; // return true\n</code></pre> <pre><code>$values = \\array_merge(\n    ['foo'],\n    ['bar'],\n    ['baz'],\n);\n\n$values === ['foo', 'bar', 'baz']; // returns true\n</code></pre> <pre><code>$values = ['foo'];\n$values[] = 'bar';\n$values[] = 'baz';\n\n$values === ['foo', 'bar', 'baz']; // returns true\n</code></pre> Tip <p>You may also come across the notation <code>$values = Sequence::of('foo')('bar')('baz')</code> in the ecosystem. This is a more math like notation to look like a matrix augmentation.</p> <p>You check the implementation of <code>Sequence::add()</code> you'll see that it is an alias to the <code>__invoke</code> method that allows this notation.</p> <p>If instead of adding a single value to the list you need to add multiple ones you would do:</p> InnmindDeclarativeImperative <pre><code>$values = Sequence::of('foo', 'bar')\n    -&gt;append(Sequence::of('baz', 'other', 'string'))\n    -&gt;toList();\n$values === ['foo', 'bar', 'baz', 'other', 'string']; // returns true\n</code></pre> <pre><code>$values = \\array_merge(\n    ['foo', 'bar'],\n    ['baz', 'other', 'string'],\n);\n$values === ['foo', 'bar', 'baz', 'other', 'string']; // returns true\n</code></pre> <pre><code>$values = ['foo', 'bar'];\n\nforeach (['baz', 'other', 'string'] as $string) {\n    $values[] = $string;\n}\n\n$values === ['foo', 'bar', 'baz', 'other', 'string']; // returns true\n</code></pre>"},{"location":"getting-started/handling-data/sequence/#filtering","title":"Filtering","text":"<p>Instead of adding values you may want to remove values from a list you're given to only keep the ones you really want.</p> <p>For example let's you have a list of cities and you only want to keep the french ones:</p> InnmindDeclarativeImperative <pre><code>$cities = Sequence::of(\n    'Paris, France',\n    'New York, USA',\n    'London, UK',\n    'Lyon, France',\n    'etc...',\n)\n    -&gt;filter(static fn(string $city) =&gt; \\str_contains($city, 'France'))\n    -&gt;toList();\n$cities === ['Paris, France', 'Lyon, France']; // returns true\n</code></pre> <pre><code>$values = \\array_filter(\n    [\n        'Paris, France',\n        'New York, USA',\n        'London, UK',\n        'Lyon, France',\n        'etc...',\n    ],\n    static fn(string $city) =&gt; \\str_contains($city, 'France'),\n);\n$cities === ['Paris, France', 'Lyon, France']; // returns true\n</code></pre> <pre><code>$cities = [\n    'Paris, France',\n    'New York, USA',\n    'London, UK',\n    'Lyon, France',\n    'etc...',\n];\n$values = [];\n\nforeach ($cities as $city) {\n    if (\\str_contains($city, 'France')) {\n        $values[] = $city;\n    }\n}\n\n$cities === ['Paris, France', 'Lyon, France']; // returns true\n</code></pre> Tip <p>And if instead you want all the cities outside of France you can replace <code>filter</code> by <code>exclude</code>.</p> <p>The <code>filter</code> method is fine if you don't need the new <code>Sequence</code> type to change, here we go from <code>Sequence&lt;string&gt;</code> to <code>Sequence&lt;string&gt;</code>. But if you have a <code>Sequence&lt;null|\\SplFileObject&gt;</code> and you want to remove the <code>null</code> values then <code>filter</code>, even though will do the job, will return a <code>Sequence&lt;null|\\SplFileObject&gt;</code>. This is a limitation of Psalm.</p> <p>To overcome this problem you should use the method <code>keep</code> that expect a <code>Predicate</code> as argument. Technically the implementation of the predicate will be the same as the function passed to <code>filter</code> but it has a mechanism that allows Psalm to understand what you intend to do.</p> <p>For our example you'd use it like this:</p> <pre><code>use Innmind\\Immutable\\Predicate\\Instance;\n\n$values = Sequence::of(null, new \\SplFileObject('some file.txt'), /* etc */)\n    -&gt;keep(Instance::of(\\SplFileObject::class));\n$values; // Sequence&lt;\\SplFileObject&gt;\n</code></pre>"},{"location":"getting-started/handling-data/sequence/#pipeline","title":"Pipeline","text":"<p>So far you've only seen how to do one action at a time. The simplicity of <code>Sequence</code> starts to shine when chaining multiple actions.</p> <p>Let's try to retrieve all the visited cities for each username, keep the french ones and remove the country from the name.</p> InnmindDeclarativeImperative <pre><code>/**\n * @return Sequence&lt;string&gt;\n */\nfunction getCities(string $username): Sequence {\n    // fake implementation\n    return match ($username) {\n        'foo' =&gt; Sequence::of('Paris, France', 'London, UK'),\n        'bar' =&gt; Sequence::of('New York, USA', 'London, UK'),\n        'baz' =&gt; Sequence::of('New York, USA', 'Lyon, France'),\n        default =&gt; Sequence::of(),\n    };\n}\n\n$cities = Sequence::of('foo', 'bar', 'baz')\n    -&gt;flatMap(static fn(string $username) =&gt; getCities($username))\n    -&gt;filter(static fn(string $city) =&gt; \\str_contains($city, 'France'))\n    -&gt;map(static fn(string $city) =&gt; \\substr($city, 0, -8))\n    -&gt;toList();\n$cities === ['Paris', 'Lyon'];\n</code></pre> <pre><code>/**\n * @return list&lt;string&gt;\n */\nfunction getCities(string $username): array {\n    // fake implementation\n    return match ($username) {\n        'foo' =&gt; ['Paris, France', 'London, UK'],\n        'bar' =&gt; ['New York, USA', 'London, UK'],\n        'baz' =&gt; ['New York, USA', 'Lyon, France'],\n        default =&gt; [],\n    };\n}\n\n$citiesPerUser = \\array_map(\n    static fn(string $username) =&gt; getCities($username),\n    ['foo', 'bar', 'baz'],\n);\n$cities = \\array_merge(...$citiesPerUser);\n$cities = \\array_filter(\n    $cities,\n    static fn(string $city) =&gt; \\str_contains($city, 'France'),\n);\n$cities = \\array_map(\n    static fn(string $city) =&gt; \\substr($city, 0, -8),\n    $cities,\n);\n$cities === ['Paris', 'Lyon'];\n</code></pre> <pre><code>/**\n * @return list&lt;string&gt;\n */\nfunction getCities(string $username): array {\n    // fake implementation\n    return match ($username) {\n        'foo' =&gt; ['Paris, France', 'London, UK'],\n        'bar' =&gt; ['New York, USA', 'London, UK'],\n        'baz' =&gt; ['New York, USA', 'Lyon, France'],\n        default =&gt; [],\n    };\n}\n\n$cities = [];\n\nforeach (['foo', 'bar', 'baz'] as $username) {\n    foreach (getCities($username) as $city) {\n        if (\\str_contains($city, 'France')) {\n            $city = \\substr($city, 0, -8);\n\n            $cities[] = $city;\n        }\n    }\n}\n\n$cities === ['Paris', 'Lyon'];\n</code></pre> <p>With the declarative and imperative approach you have to deal with either a lot of indentation or a lot of variables. With a <code>Sequence</code> you just keep chaining methods.</p> <p>Another nice upside to <code>Sequence</code> is when you try to build a pipeline and want to see the different results if you switch some logic around. To achieve it you only need to move a method call up or down, while the other approaches you need to be aware of conflicting variables.</p>"},{"location":"getting-started/handling-data/sequence/#extracting-data","title":"Extracting data","text":"<p>At some point you'll need to extract the values contained in a <code>Sequence</code> (1). So far you've only seen <code>toList</code> that return all the values in an <code>array</code>.</p> <ol> <li>For persisting them to a database, sending them in an HTTP response, etc...</li> </ol>"},{"location":"getting-started/handling-data/sequence/#computing-a-value","title":"Computing a value","text":"InnmindDeclarativeImperative <pre><code>$sum = Sequence::of(1, 2, 3, 4)-&gt;reduce(\n    0,\n    static fn(int $carry, int $value) =&gt; $carry + $value,\n);\n$sum === 10; // returns true\n</code></pre> <pre><code>$sum = \\array_reduce(\n    [1, 2, 3, 4],\n    static fn(int $carry, int $value) =&gt; $carry + $value,\n    0,\n);\n$sum === 10; // returns true\n</code></pre> <pre><code>$sum = 0;\n\nforeach ([1, 2, 3, 4] as $value) {\n    $sum += $value;\n}\n\n$sum === 10; // returns true\n</code></pre>"},{"location":"getting-started/handling-data/sequence/#fetching-a-value-at-an-index","title":"Fetching a value at an index","text":"InnmindImperative <pre><code>$values = Sequence::of(1, 2, 3, 4);\n$value1 = $values-&gt;get(1)-&gt;match(\n    static fn(int $value) =&gt; $value,\n    static fn() =&gt; null,\n);\n$value2 = $values-&gt;get(100)-&gt;match(\n    static fn(int $value) =&gt; $value,\n    static fn() =&gt; null,\n);\n$value1 === 2; // returns true\n$value2 === null; // returns true\n</code></pre> <pre><code>$values = [1, 2, 3, 4];\n\nif (\\array_key_exists(1, $values)) {\n    $value1 = $values[1];\n} else {\n    $value1 = null;\n}\n\nif (\\array_key_exists(100, $values)) {\n    $value2 = $values[100];\n} else {\n    $value2 = null;\n}\n\n$value1 === 2; // returns true\n$value2 === null; // returns true\n</code></pre> Info <p>The imperative approach could be simplified via <code>$values[$index] ?? null</code>, but then if the value at the index is itself <code>null</code> you can't differentiate if the index exists or not.</p>"},{"location":"getting-started/handling-data/sequence/#and-more","title":"And more","text":"<p>Above are a few examples of the way to extract data. You should look at all the methods available on the <code>Sequence</code> class to see if one fit your needs.</p>"},{"location":"getting-started/handling-data/sequence/#execution-mode","title":"Execution mode","text":"<p>The power of <code>Sequence</code> is that you can change the way its implementation behave depending on your needs, without rearchitecting your whole program. You'll usually switch the mode for performance reasons.</p>"},{"location":"getting-started/handling-data/sequence/#in-memory","title":"In memory","text":"<p>This is the mode you've seen so far. When calling <code>Sequence::of()</code> you specify all the values and they're kept in memory.</p>"},{"location":"getting-started/handling-data/sequence/#deferred","title":"Deferred","text":"<p>Instead of specyfying the values you can use a <code>Generator</code> to populate the <code>Sequence</code>. Once a value is loaded it's kept in memory. The advantage is that you can loop over the same generator multiple times (1).</p> <ol> <li>Using a <code>Generator</code> directly requires to call again the function that created it. But this means you may not end up with the same values (especially if generating objects).</li> </ol> <pre><code>$values = Sequence::of(1, 2, 3, 4);\n// becomes\n$values = Sequence::defer((static function() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n})());\n</code></pre> <p>The <code>Sequence</code> is then used exactly the same way as an in memory one.</p> <p>You should use this mode when loading values may be expensive and you're not sure all the values will be loaded. This way you save a bit of time and memory by not fetching the values you don't end up needing.</p>"},{"location":"getting-started/handling-data/sequence/#lazy","title":"Lazy","text":"<p>With this mode you build a <code>Sequence</code> by passing a function that returns a <code>Generator</code>. This function will be called each time you try to extract some data from the <code>Sequence</code>.</p> <pre><code>$values = Sequence::lazy(static function() {\n    $file = \\fopen('some file.txt', 'r');\n\n    while ($chunk = \\fgets($file, 256)) {\n        yield $chunk;\n    }\n});\n</code></pre> <p>The <code>Sequence</code> is then used exactly the same way as an in memory one.</p> <p>You should use this mode to handle an infinite list of values or a list of values that can't fit in memory (1).</p> <ol> <li>Such as reading a multi gigabyte file or reading from a socket.</li> </ol> Info <p>This is where lies the root of the power of Innmind. Being able to work with infinte volumes of data as if it were in memory.</p>"},{"location":"getting-started/handling-data/sequence/#tips","title":"Tips","text":""},{"location":"getting-started/handling-data/sequence/#lazyness","title":"Lazyness","text":"<p>When using <code>::defer()</code> or <code>::lazy()</code> your code won't be called until you try to extract data (1) or call the <code>memoize</code> method.</p> <ol> <li>Any method that return something else than a monad (<code>Sequence</code>, <code>Set</code> or <code>Maybe</code>).</li> </ol> <p>For example if you want to print all the lines from a file, this will do nothing:</p> <pre><code>Sequence::lazy(static function() {\n    $file = \\fopen('some file.txt', 'r');\n\n    while ($line = \\fgets($file)) {\n        yield $line;\n    }\n})-&gt;map(static function($line) {\n    echo $line;\n});\n</code></pre> <p>This does nothing because <code>map</code> returns a new lazy <code>Sequence</code> with a <code>null</code> value for each line. Instead you should do:</p> <pre><code>Sequence::lazy(static function() {\n    $file = \\fopen('some file.txt', 'r');\n\n    while ($line = \\fgets($file)) {\n        yield $line;\n    }\n})-&gt;foreach(static function($line) {\n    echo $line;\n});\n</code></pre> <p><code>foreach</code> returns a <code>Innmind\\Immutable\\SideEffect</code> so the <code>Sequence</code> knows that it needs to call all the logic you specified.</p>"},{"location":"getting-started/handling-data/sequence/#psalm","title":"Psalm","text":"<p>If you call the <code>foreach</code> method you won't be able to use the returned value as it's an object that does nothing. It's returned because <code>Sequence</code> is an immutable class, meaning all methods must return a value otherwise Psalm tells that the method is useless.</p> <p>But you still need to assign the returned value to a variable <code>$_</code> (1) otherwise Psalm will tell you that the call to <code>foreach</code> does nothing.</p> <ol> <li>Called a sink. Psalm won't run any analysis on this variable because it starts with an underscore.</li> </ol>"},{"location":"getting-started/handling-data/sequence/#in-the-ecosystem","title":"In the ecosystem","text":"<p>You'll find this class used pretty much everywhere in this ecosystem at it allows to describe:</p> <ul> <li>a list of values</li> <li>a file as a lazy list of chunks</li> <li>a file as a lazy list of lines</li> <li>a directory as lazy list of files</li> <li>a socket as a lazy list of frames</li> <li>a SQL result as a lazy list of rows</li> <li>a process output as a lazy list of chunks</li> <li>and more...</li> </ul>"},{"location":"getting-started/operating-system/","title":"Operating System","text":"<p>This package allows you to deal with all interactions with the operating system in a declarative way.</p>"},{"location":"getting-started/operating-system/#usage","title":"Usage","text":"<pre><code>use Innmind\\OperatingSystem\\{\n    Factory,\n    OperatingSystem,\n};\n\n$os = Factory::build();\n$os instanceof OperatingSystem; // returns true\n</code></pre> <p>You'll see in the following chapters all the ways you can use this object.</p> <p>From this point on everytime you see the variable <code>$os</code> it refers to this object.</p> Warning <p>This package is not compatible with Windows.</p>"},{"location":"getting-started/operating-system/#advanced-usage","title":"Advanced usage","text":"<p>Full documentation available here.</p>"},{"location":"getting-started/operating-system/clock/","title":"Clock","text":"<p>PHP allows to access time anywhere in a program in various ways (1) but this becomes problematic when you want to test your program. Especially if it depends heavily on time.</p> <ol> <li><code>time</code>, <code>new \\DateTime</code>, etc...</li> </ol> <p>By using a clock object that you inject everywhere you need to access time you'll be able to configure the date on which your program is tested. This means that you can test your program in the past (1), present and future (2).</p> <ol> <li>So you can reproduce bugs that appeared in production.</li> <li>You can anticipate problematic times such as leap years, daylight saving time, etc...</li> </ol> <p>And to ease the manipulation, all objects are immutable.</p>"},{"location":"getting-started/operating-system/clock/#accessing-time","title":"Accessing time","text":"<pre><code>use Innmind\\TimeContinuum\\{\n    PointInTime,\n    Format,\n};\n\necho $os\n    -&gt;clock()\n    -&gt;now() // returns a PointInTime object\n    -&gt;format(Format::iso8601());\n</code></pre> <p>This will print something like <code>2024-05-04T13:05:01+02:00</code>.</p> <p>You can specify your own formats with the named constructor <code>Innmind\\TimeContinuum\\Format::of()</code>. The format itself is described by a string that must be understood by the <code>\\DateTimeInterface::format()</code> method.</p> <p>On a <code>PointInTime</code> you can access every part of the time it references (year, month, day, etc...), and has methods to modify the time to move forward or backward in time.</p>"},{"location":"getting-started/operating-system/clock/#parsing-time-from-a-string","title":"Parsing time from a string","text":"<p>When you receive a <code>string</code> (1) that represent a date and you want to convert it to a <code>PointInTime</code> you should also use the clock:</p> <ol> <li>from an HTTP request or loading it from a database</li> </ol> <pre><code>$point = $os\n    -&gt;clock()\n    -&gt;at($string, Format::iso8601()) #(1)\n    -&gt;match(\n        static fn(PointInTime $point) =&gt; $point,\n        static fn() =&gt; throw new \\RuntimeException(\"'$string' is not a valid date\"),\n    );\n</code></pre> <ol> <li>The format is required to avoid implicit convertions.</li> </ol> <p>The <code>at</code> method returns the <code>Maybe&lt;PointInTime&gt;</code> type to make sure you always handle the case the <code>$string</code> is invalid.</p>"},{"location":"getting-started/operating-system/clock/#calculating-elapsed-time","title":"Calculating elapsed time","text":"<p>We need to calculate elapsed time, among other cases, when handling heartbeats when dealing with sockets or in tests to make sure some code is executed in a certain amount of time.</p> <p>The usual approach is to use a call to <code>microtime()</code> at the start and an another at the end and subtract them. The problem with this approach is that you can end up with a negative durations. This happens when your machine re-synchronise its clock via the NTP protocol and sometimes it can go back in time (1).</p> <ol> <li>To avoid this problem the solution is to use a monotonic clock (via the <code>hrtime()</code> PHP function).</li> </ol> <p>With Innmind you don't have to worry about that!</p> <pre><code>$start = $os-&gt;clock()-&gt;now();\n\n// do some stuff\n\n$duration = $os\n    -&gt;clock()\n    -&gt;now()\n    -&gt;elapsedSince($start);\n</code></pre> <p>Here <code>$duration</code> is an instance of <code>Innmind\\TimeContinuum\\ElapsedPeriod</code> that contains the number of seconds, milliseconds and microseconds between the 2 points in time. And it handles the case that your machine may go back in time.</p> Info <p>The time shift is handled when working with objects coming from <code>$clock-&gt;now()</code>, this is not the case when working with objects coming from <code>$clock-&gt;at()</code>.</p>"},{"location":"getting-started/operating-system/clock/#in-the-ecosystem","title":"In the ecosystem","text":"<p>All packages that depend on this abstraction use this clock, but this abstraction itself also uses this clock. So no matter the level of abstractions you work on you can change the clock implementation in your tests.</p>"},{"location":"getting-started/operating-system/clock/#full-documentation","title":"Full documentation","text":"<p>A more extensive documentation can be found at https://innmind.org/TimeContinuum/.</p>"},{"location":"getting-started/operating-system/filesystem/","title":"Filesystem","text":""},{"location":"getting-started/operating-system/filesystem/#access","title":"Access","text":""},{"location":"getting-started/operating-system/filesystem/#concepts","title":"Concepts","text":"<p>Files and directories are accessed via <code>Adapter</code>s that are mounted through the <code>$os</code>.</p> <p>A <code>Directory</code> is represented by a <code>Name</code> and an immutable <code>Sequence</code> of files and directories.</p> <p>A <code>File</code> is represented by a <code>Name</code>, a <code>MediaType</code> and a <code>Content</code>.</p> <p>A <code>Content</code> is either viewed as an immutable <code>Sequence</code> of <code>Line</code>s or of chunks. This allows to handle human readable files line by line and alter them like any other <code>Sequence</code>. And to handle binary files as a <code>Sequence</code> of <code>Str</code> chunks.</p> <p>Since a <code>Content</code> can be described via a <code>Sequence</code>, anytime you see a <code>Sequence</code> you have an opportunity to convert it into a <code>Content</code>.</p> Note <p>Even though a <code>Content</code> is immutable it loads the content from the filesystem upon use. This means that if a process deletes the file between the time you retrieved the <code>File</code> and the time you work with its <code>Content</code> your program will fail.</p> <p>So be careful of the concurrency in your program!</p> <p>Via these immutable structures you can describe your filesystem structures in a pure code and apply it later on in your program.</p>"},{"location":"getting-started/operating-system/filesystem/#accessing-files","title":"Accessing files","text":"<pre><code>use Innmind\\Filesystem\\{\n    File,\n    Name,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Predicate\\Instance;\n\n$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some directory/')) #(1)\n    -&gt;unwrap()\n    -&gt;get(Name::of('some-file.txt'))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;match(\n        static fn(File $file) =&gt; doStuff($file-&gt;content()-&gt;toString()),\n        static fn() =&gt; fileDoesntExist(),\n    );\n</code></pre> <ol> <li>The path must end with a <code>/</code>.</li> </ol> <p>This reads the content of the file at <code>some directory/some-file.txt</code>. But if your file is located under a <code>sub folder</code> you would do:</p> <pre><code>use Innmind\\Filesystem\\Directory;\n\n$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some directory/'))\n    -&gt;unwrap()\n    -&gt;get(Name::of('sub folder'))\n    -&gt;keep(Instance::of(Directory::class))\n    -&gt;flatMap(static fn(Directory $directory) =&gt; $directory-&gt;get(\n        Name::of('some-file.txt'),\n    ))\n    -&gt;match(\n        static fn(File $file) =&gt; doStuff($file-&gt;content()-&gt;toString()),\n        static fn() =&gt; fileDoesntExist(),\n    );\n</code></pre> Note <p>You can use any level of directory nesting, as long as it's supported by your machine's filesystem.</p> <p>If you want to access all the files at the root of the adapter you can do:</p> <pre><code>$files = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some directory/'))\n    -&gt;unwrap()\n    -&gt;root()\n    -&gt;all()\n    -&gt;keep(Instance::of(File::class));\n$files; // instance of Sequence&lt;File&gt;\n</code></pre>"},{"location":"getting-started/operating-system/filesystem/#persisting-files","title":"Persisting files","text":"<p>To add a file at the root of the adapter you can do:</p> <pre><code>$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some directory/'))\n    -&gt;unwrap()\n    -&gt;add(File::named(\n        'some name',\n        Content::ofString('the file content'),\n    ))\n    -&gt;unwrap();\n</code></pre> Note <p>If the write fails for any reason it will throw an exception. But since the files and directories are immutable you can retry them safely.</p> <p>You can construct the content of a file either via:</p> <ul> <li><code>Content::ofString()</code> where the string is the whole file, but beware of memory allocation</li> <li><code>Content::ofLines()</code> that expect a <code>Sequence&lt;Content\\Line&gt;</code>, this automatically handles the lines feed character</li> <li><code>Content::ofChunks()</code> that expect a <code>Sequence&lt;Innmind\\Immutable\\Str&gt;</code></li> <li><code>Content::none()</code> to create an empty file</li> </ul> <p>If you want to create a file inside a directory you can do:</p> <pre><code>$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some directory/'))\n    -&gt;unwrap()\n    -&gt;add(\n        Directory::named('sub folder')-&gt;add(\n            File::named(\n                'some name',\n                Content::ofString('the file content'),\n            ),\n        ),\n    )\n    -&gt;unwrap();\n</code></pre> <p>Note</p> <p>If the <code>sub folder/</code> already exist it will add your file, any other file inside it won't be affected.</p>"},{"location":"getting-started/operating-system/filesystem/#removing-files","title":"Removing files","text":"<p>If you want to remove a file/directory at the root of the adapter you can do:</p> <pre><code>$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some directory/'))\n    -&gt;unwrap()\n    -&gt;remove(Name::of('some file'))\n    -&gt;unwrap();\n</code></pre> <p>Note</p> <p>If you delete a directory it will automatically remove all files inside it!</p> <p>If the file/directory doesn't exist it will do nothing, since the end result is the same (the absence of the file/directory).</p> <p>To remove a file inside a directory you add a new version of the directory:</p> <pre><code>$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some directory/'))\n    -&gt;unwrap()\n    -&gt;add(\n        Directory::named('sub folder')-&gt;remove(\n            Name::of('some file'),\n        ),\n    )\n    -&gt;unwrap();\n</code></pre> Info <p>Alternatively you can also retrieve the directory, remove the file and re-add the new directory object. However this will be less performant.</p>"},{"location":"getting-started/operating-system/filesystem/#modifying-file-content","title":"Modifying file content","text":"<p>Let's say you have a log file that you want to duplicate but containing only the errors you can do:</p> <pre><code>$adapter = $os-&gt;filesystem()-&gt;mount(Path::of('logs/'))-&gt;unwrap();\n$adapter\n    -&gt;get(Name::of('prod.log'))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;map(\n        static fn(File $file) =&gt; $file\n            -&gt;rename(Name::of('errors.log'))\n            -&gt;withContent(\n                $file\n                    -&gt;content()\n                    -&gt;filter(\n                        static fn(Line $line) =&gt; $line\n                            -&gt;str()\n                            -&gt;contains('app.ERROR'),\n                    ),\n            ),\n    )\n    -&gt;match(\n        static fn(File $file) =&gt; $adapter-&gt;add($file)-&gt;unwrap(),\n        static fn() =&gt; null, // prod.log doesn't exist\n    );\n</code></pre> <p>You can use <code>Content::map()</code> to change each line of a file. <code>Content::flatMap()</code> allows to replace one line by multiple ones, you can use this to merge multiple files together.</p> Warning <p>You can't write to the file you're trying to modify. This means you can't do this:</p> <pre><code>$adapter\n    -&gt;get(Name::of('some file'))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;map(static fn(File $file) =&gt; $file-&gt;withContent(\n        $file\n            -&gt;content()\n            -&gt;map(static fn(Line $line) =&gt; Line::of(Str::of('some value'))),\n    ))\n    -&gt;match(\n        static fn(File $file) =&gt; $adapter-&gt;add($file)-&gt;unwrap(),\n        static fn() =&gt; null,\n    );\n</code></pre> <p>You need to write the modified version to a temporary file, read this file to write it to the original file. But a feature is planned to allow to do in place modification.</p>"},{"location":"getting-started/operating-system/filesystem/#watching-for-changes","title":"Watching for changes","text":"<p>Let's say you have a directory and you want to execute some code every time someone adds a file to it. You can do this:</p> <pre><code>use Innmind\\FileWatch\\Continuation;\nuse Innmind\\Url\\Path;\n\n$watch = $os-&gt;filesystem()-&gt;watch(Path::of('some directory/'));\n$result = $watch(\n    0,\n    static function(int $count, Continuation $continuation) {\n        if ($count === 42) {\n            return $continuation-&gt;stop($count);\n        }\n\n        doStuff();\n\n        return $continuation-&gt;continue($count + 1);\n    },\n);\n</code></pre> <p>Here you'll react to <code>42</code> modifications of the directory <code>some directory/</code> and then assign <code>42</code> to <code>$result</code>. In essence this acts as a reduce operation that could be infinite.</p> <p><code>0</code> and <code>int $count</code> are a carried value between each call of the function. Here it's an <code>int</code> but you can use any type you want.</p> Warning <p>You should not use this method in production as it executes a <code>stat</code> command every second.</p>"},{"location":"getting-started/operating-system/filesystem/#loading-php-files","title":"Loading PHP files","text":"<p>Let's say you have a script that may be configured by an external PHP file. The config file may or may not exist and your script need to adapt to that.</p> config.php<pre><code>return [\n    'some' =&gt; 'value',\n    'key' =&gt; 'foo',\n];\n</code></pre> <p>In your script you can do:</p> <pre><code>$config = $os\n    -&gt;filesystem()\n    -&gt;require(Path::of('config.php'))\n    -&gt;match(\n        static fn(array $config) =&gt; $config,\n        static fn() =&gt; [\n            'some' =&gt; 'default value',\n            'key' =&gt; 'default value',\n        ],\n    );\n</code></pre> <p>If the file exist then the return value from <code>config.php</code> is passed to the first callable passed to <code>match</code> otherwise the second callable is called.</p> <p>Here the returned value is an <code>array</code> but it can be any value.</p>"},{"location":"getting-started/operating-system/http/","title":"HTTP","text":"<p>This HTTP client uses the immutable objects describing the protocol from the <code>innmind/http</code> package.</p>"},{"location":"getting-started/operating-system/http/#usage","title":"Usage","text":"<pre><code>use Innmind\\HttpTransport\\Success;\nuse Innmind\\Http\\{\n    Request,\n    Method,\n    ProtocolVersion,\n};\nuse Innmind\\Url\\Url;\n\n$http = $os-&gt;remote()-&gt;http();\n\n$request = Request::of(\n    Url::of('https://github.com/'),\n    Method::get,\n    ProtocolVersion::v11,\n);\n$http($request)-&gt;match(\n    static fn(Success $success) =&gt; var_dump(\n        $success\n            -&gt;response()\n            -&gt;body()\n            -&gt;toString(),\n    ),\n    static fn(object $error) =&gt; throw new \\RuntimeException(),\n);\n</code></pre> <p>When sending an HTTP request it will return an <code>Either&lt;Failure|ConnectionFailed|MalformedResponse|Information|Redirection|ClientError|ServerError, Success&gt;</code>, where each of this classes are located in the <code>Innmind\\HttpTransport\\</code> namespace. This type may be scarry at first but it allows you to use static analysis to deal with every possible situation (or not by throwing an exception like in the example). No more surprises of uncaught exceptions in production!</p> Info <p>Responses are wrapped in classes such as <code>Success</code>, <code>Redirection</code>, etc... to avoid confusion as a response can be on both sides of the <code>Either</code>. This way you know for sure a <code>2XX</code> response is on the right side and the other ones on the left one.</p> <p>You can specify headers on your requests like this:</p> <pre><code>use Innmind\\Http\\{\n    Headers,\n    Header,\n    Header\\Value,\n};\n\n$request = Request::of(\n    Url::of('https://github.com/'),\n    Method::get,\n    ProtocolVersion::v11,\n    Headers::of(\n        Header::of('User-Agent', Value::of('your custom user agent string')),\n    ),\n);\n</code></pre> Tip <p><code>innmind/http</code> comes with a lot of header classes to simplify some common cases.</p> <p>You can always specify a body like so:</p> <pre><code>use Innmind\\Filesystem\\File\\Content;\nuse Innmind\\Http\\Header\\ContentType;\nuse Innmind\\MediaType\\MediaType;\nuse Innmind\\Json\\Json;\n\n$request = Request::of(\n    Url::of('https://your-service.com/api/some-endpoint'),\n    Method::post,\n    ProtocolVersion::v11,\n    Headers::of(\n        ContentType::of(new MediaType('application', 'json')),\n    ),\n    Content::ofString(Json::encode(['some' =&gt; 'payload'])),\n);\n</code></pre> <p>Here we send some json but you can send anything you want.</p> <p>The body of a <code>Request</code>, and a <code>Response</code>, is expressed via the <code>Content</code> class from the filesystem abstraction. This means that it can contain any valid file content.</p> <p>You'll learn more on this <code>Content</code> in the next chapter.</p>"},{"location":"getting-started/operating-system/http/#following-redirections","title":"Following redirections","text":"<p>By default the client returned by <code>$os-&gt;remote()-&gt;http()</code> doesn't follow redirections. In order to do so you need to decorate the client like this:</p> <pre><code>use Innmind\\HttpTransport\\FollowRedirections;\n\n$http = FollowRedirections::of($os-&gt;remote()-&gt;http());\n</code></pre> <p>This decorator will follow to up to <code>5</code> redirections.</p> Info <p>Redirections are handled this way so you can compose all the decorators the way you need. For example you want to apply exponential backoff between each redirection.</p>"},{"location":"getting-started/operating-system/http/#resiliency","title":"Resiliency","text":"<p>We tend to think networks are always stable or services as always up, but at some point failures will happen. This abstraction comes with 2 strategies to deal with them.</p>"},{"location":"getting-started/operating-system/http/#circuit-breaker","title":"Circuit breaker","text":"<p>If you need to call a service a lot but at some point becomes unavailable (for maintenance for example), you don't want to continue to try to call this service for a certain amount of time.</p> <p>The circuit breaker is a pattern that will automatically return an error response (without doing the actual call) if the service failed in the previous <code>x</code> amount of time.</p> <p>You apply this pattern via this decorator:</p> <pre><code>use Innmind\\HttpTransport\\CircuitBreaker;\nuse Innmind\\TimeContinuum\\Period;\n\n$http = CircuitBreaker::of(\n    $os-&gt;remote()-&gt;http(),\n    $os-&gt;clock(),\n    Period::second(10),\n);\n</code></pre> <p>The circuit breaks on a per domain name logic.</p> Info <p>In case a circuit is open then the error response will be a <code>503 Service Unavailable</code> with a custom header <code>X-Circuit-Opened</code> so you can understand who responded.</p>"},{"location":"getting-started/operating-system/http/#retry-with-exponential-backoff","title":"Retry with exponential backoff","text":"<p>When a call fail you can automatically retry the call after a certain amount of time. You can apply the retries like this:</p> <pre><code>use Innmind\\HttpTransport\\ExponentialBackoff;\n\n$http = ExponentialBackoff::of(\n    $os-&gt;remote()-&gt;http(),\n    $os-&gt;process()-&gt;halt(...),\n);\n</code></pre> <p>This will retry all errors <code>5XX</code> responses and connection failures at most 5 times and will wait <code>100ms</code>, <code>271ms</code>, <code>738ms</code>, <code>2s</code> and <code>5.4s</code> between each retry.</p> Tip <p>You can improve the resiliency of the whole operating system abstractions like this:</p> <pre><code>use Innmind\\OperatingSystem\\Config\\Resilient;\n\n$os = $os-&gt;map(Resilient::new());\n</code></pre> <p>Even though for now it only applies this strategy to the HTTP client, you future prood yourself by using this config.</p>"},{"location":"getting-started/operating-system/http/#traps","title":"Traps","text":""},{"location":"getting-started/operating-system/http/#unsent-requests","title":"Unsent requests","text":"<p>The HTTP client doesn't send the request when you call <code>$http($request)</code> to allow for concurrent calls. The call is actually done when you call <code>-&gt;match()</code> on the returned <code>Either</code>.</p> <p>This means that this code will not send the request:</p> <pre><code>$http = $os-&gt;remote()-&gt;http();\n$http(Request::of(\n    Url::of('https://your-service.com/api/some-resource'),\n    Method::delete,\n    ProtocolVersion::v11,\n));\n</code></pre> <p>Even if you don't care about the response you need to do this:</p> <pre><code>$http = $os-&gt;remote()-&gt;http();\n$http(Request::of(\n    Url::of('https://your-service.com/api/some-resource'),\n    Method::delete,\n    ProtocolVersion::v11,\n))-&gt;match(\n    static fn() =&gt; null,\n    static fn() =&gt; null,\n);\n</code></pre>"},{"location":"getting-started/operating-system/http/#streaming","title":"Streaming","text":"<p>The default client uses <code>cURL</code> under the hood and the way it is structured prevents the streaming of requests/responses.</p> Info <p>However the work of the distributed abstraction will require the default client to switch to an implementation based on sockets that will open the door to streaming.</p>"},{"location":"getting-started/operating-system/monitoring/","title":"Monitoring","text":""},{"location":"getting-started/operating-system/monitoring/#processes","title":"Processes","text":"<p>You can access information on all processes currently running on the machine via:</p> <pre><code>use Innmind\\Server\\Status\\Server\\Process;\n\n$os\n    -&gt;status()\n    -&gt;processes()\n    -&gt;all()\n    -&gt;foreach(static function(Process $process): void {\n        \\printf(\n            '%s is running %s',\n            $process-&gt;user()-&gt;toString(),\n            $process-&gt;command()-&gt;toString(),\n        );\n    });\n</code></pre> <p>On each process you have access to:</p> <ul> <li>its pid</li> <li>the user that started it</li> <li>the current cpu percentage</li> <li>the current amount of memory used</li> <li>when it started (may not always be available)</li> <li>the command</li> </ul> <p>The cpu and memory usage is a snapshot of when you called <code>-&gt;all()</code>. If you want an updated value you need to refetch the process via:</p> <pre><code>$updatedProcess = $os\n    -&gt;status()\n    -&gt;processes()\n    -&gt;get($process-&gt;pid());\n</code></pre> Info <p>Since the process may have finished in the meantime <code>-&gt;get()</code> returns a <code>Maybe&lt;Process&gt;</code>.</p>"},{"location":"getting-started/operating-system/monitoring/#disk","title":"Disk","text":"<p>You can access all the mounted volumes via:</p> <pre><code>use Innmind\\Server\\Status\\Server\\Disk\\Volume;\n\n$os\n    -&gt;status()\n    -&gt;disk()\n    -&gt;volumes()\n    -&gt;foreach(static function(Volume $volume): void {\n        \\printf(\n            '%s uses %s',\n            $volume-&gt;mountPoint()-&gt;toString(),\n            $volume-&gt;used()-&gt;toString(),\n        );\n    });\n</code></pre> <p>On each volume you have access to its mount point and its usage. The values are a snapshot of when you called <code>-&gt;volumes()</code>, if you want an updated value you need to refetch the volumes.</p>"},{"location":"getting-started/operating-system/monitoring/#cpu","title":"CPU","text":"<pre><code>$cpu = $os\n    -&gt;status()\n    -&gt;cpu()\n    -&gt;unwrap();\n</code></pre> <p>On <code>$cpu</code> you have access to a snapshot of the percentage of cpu used by the user or the system. You also have access to the number of cores available, you can use this information to adapt your program if you want to start child processes.</p>"},{"location":"getting-started/operating-system/monitoring/#memory","title":"Memory","text":"<pre><code>$memory = $os\n    -&gt;status()\n    -&gt;memory()\n    -&gt;unwrap();\n</code></pre> <p>On <code>$memory</code> you have access to a snapshot of the memory used, the swap used and the total memory available.</p>"},{"location":"getting-started/operating-system/monitoring/#load-average","title":"Load average","text":"<pre><code>$load = $os\n    -&gt;status()\n    -&gt;loadAverage()\n    -&gt;unwrap();\n$load-&gt;lastMinute();\n$load-&gt;lastFiveMinutes();\n$load-&gt;lastFifteenMinutes();\n</code></pre> <p>You can use this load average to know if you can handle more work in your program or start throttling.</p>"},{"location":"getting-started/operating-system/monitoring/#temporary-directory","title":"Temporary directory","text":"<pre><code>$tmp = $os\n    -&gt;status()\n    -&gt;tmp();\n</code></pre> <p><code>$tmp</code> is a <code>Innmind\\Url\\Path</code> that you can use to mount a filesystem or use as a working directory when launching processes.</p>"},{"location":"getting-started/operating-system/network/","title":"Network","text":""},{"location":"getting-started/operating-system/network/#unix-socket","title":"Unix socket","text":"<p>If you look to communicate between processes you should head to the IPC chapter.</p>"},{"location":"getting-started/operating-system/network/#server","title":"Server","text":"<p>The first part to build a socket server is to accept incoming connections at an address:</p> <pre><code>use Innmind\\IO\\Sockets\\{\n    Servers\\Server,\n    Unix\\Address,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\Sequence;\n\n$server = $os\n    -&gt;sockets()\n    -&gt;open(Address::of(Path::of('/tmp/some-socket-name')))\n    -&gt;match(\n        static fn(Server $server) =&gt; $server,\n        static fn($e) =&gt; throw $e,\n    );\n$clients = Sequence::of();\n\nwhile (true) {\n    $clients = $server\n        -&gt;watch()\n        -&gt;accept()\n        -&gt;maybe()\n        -&gt;toSequence()\n        -&gt;append($clients);\n}\n</code></pre> <p>This will wait forever for a connection to open, when it does it's added to <code>$clients</code> and then resume watching for new connections.</p> <p>The next step is to define a protocol. Let's take a silly example where when connecting a client must send <code>hello world\\n</code> followed by their message ending with <code>\\n</code>. You can define such protocol like this:</p> <pre><code>use Innmind\\IO\\Frame;\nuse Innmind\\Immutable\\Str;\n\n$protocol = Frame::chunk(12)\n    -&gt;strict()\n    -&gt;flatMap(static fn(Str $hello) =&gt; Frame::line())\n    -&gt;map(static fn(Str $message) =&gt; $message-&gt;rightTrim(\"\\n\"));\n</code></pre> <p><code>Frame::chunk(12)-&gt;strict()</code> expresses the expected hello world string. <code>flatMap</code> expresses what to do next with the read value, in this case we tell that we want a line ending with <code>\\n</code>. <code>map</code> transform the line read previously to remove the <code>\\n</code> at the end since it's not part of the message.</p> Info <p>You can explore the <code>Innmind\\IO\\Frame</code> constructors to see the other kind of frames you can use.</p> <p>You can look at <code>innmind/http-parser</code> or <code>innmind/amqp</code> for concrete examples of protocols defined this way.</p> Tip <p>Here the <code>map</code> only modifies the message but you can change the value to any type you wish. It's even encouraged to encapsulate the data in your own classes to make sure it's the format you expect.</p> <p>You can use then the procol like this:</p> <pre><code>use Innmind\\IO\\Sockets\\Client;\nuse Innmind\\Immutable\\Str;\n\n$server\n    -&gt;watch()\n    -&gt;accept()\n    -&gt;flatMap(\n        static fn(Client $client) =&gt; $client\n            -&gt;toEncoding(Str\\Encoding::ascii)\n            -&gt;watch()\n            -&gt;frames($protocol)\n            -&gt;one(),\n    )\n    -&gt;match(\n        static fn(Str $message) =&gt; $message,\n        static fn() =&gt; null, // either no connection or failed to read the message\n    );\n</code></pre> <p>Sending data to the incoming connection is the same way as from the client side (see below).</p>"},{"location":"getting-started/operating-system/network/#client","title":"Client","text":"<p>To connect to a server you can do:</p> <pre><code>use Innmind\\IO\\Sockets\\{\n    Clients\\Client,\n    Unix\\Address,\n};\nuse Innmind\\Url\\Path;\n\n$client = $os\n    -&gt;sockets()\n    -&gt;connectTo(Address::of(Path::of('/tmp/some-socket-name')))\n    -&gt;match(\n        static fn(Client $client) =&gt; $client,\n        static fn($e) =&gt; throw $e,\n    );\n</code></pre> <p>Then to send data:</p> <pre><code>use Innmind\\Immutable\\{\n    Str,\n    Sequence,\n};\n\n$client\n    -&gt;toEncoding(Str\\Encoding::ascii)\n    -&gt;sink(Sequence::of(\n        Str::of(\"hello world\\nThis is your message\\n\"),\n    ))\n    -&gt;match(\n        static fn() =&gt; null, // message sent\n        static fn($e) =&gt; throw $e,\n    );\n</code></pre> Info <p>As you can see <code>sink</code> expect a <code>Sequence</code> of messages meaning you can send multiple ones. This is so you don't have to loop yourself.</p> <p>In case you use a lazy sequence and you want to abort midway (say because a signal tells you to stop), you can do it like this:</p> <pre><code>$signaled = false;\n$client\n    -&gt;abortWhen(static function() use (&amp;$signaled) {\n        return $signaled;\n    })\n    -&gt;sink($messages)\n    -&gt;match(\n        static fn() =&gt; null, // message sent\n        static fn($e) =&gt; throw $e,\n    );\n</code></pre> <p>If the sending is aborted then it will always reach the error case, here meaning it will throw the exception.</p> <p>If you want to read data coming from the server you'd do it the same way the server does (see above).</p>"},{"location":"getting-started/operating-system/network/#over-the-wire","title":"Over the wire","text":"<p>This works exactly the same way as unix sockets except for the method to open the server and the method to connect to it:</p> Open serverOpen connection <pre><code>use Innmind\\IO\\Sockets\\{\n    Servers\\Server\n    Internet\\Transport,\n};\nuse Innmind\\IP\\IP;\nuse Innmind\\Url\\Authority\\Port;\n\n$server = $os\n    -&gt;ports()\n    -&gt;open(\n        Transport::tcp(),\n        IP::v4('0.0.0.0'),\n        Port::of(8080),\n    )\n    -&gt;match(\n        static fn(Server $server) =&gt; $server,\n        static fn($e) =&gt; throw $e,\n    );\n</code></pre> <pre><code>use Innmind\\IO\\Sockets\\{\n    Clients\\Client\n    Internet\\Transport,\n};\nuse Innmind\\Url\\Url;\n\n$client = $os\n    -&gt;remote()\n    -&gt;socket(\n        Transport::tcp(),\n        Url::of('tcp://machine-ip:8080/')-&gt;authority(),\n    )\n    -&gt;match(\n        static fn(Client $client) =&gt; $client,\n        static fn($e) =&gt; throw $e,\n    );\n</code></pre>"},{"location":"getting-started/operating-system/php-process/","title":"PHP Process","text":""},{"location":"getting-started/operating-system/php-process/#pausing","title":"Pausing","text":"<p>If you need to pause your program to wait for external thing to happen (or any other reason), you can pause it this way:</p> <pre><code>use Innmind\\TimeContinuum\\Period;\n\n$os\n    -&gt;process()\n    -&gt;halt(Period::second(10));\n</code></pre> <p>You can use any unit of period except months because it's not an absolute value.</p> Info <p>If you want to wait for years it will compute that as <code>365</code> days. But if you need to do this there may be a design problem in your program.</p>"},{"location":"getting-started/operating-system/php-process/#handling-cli-signals","title":"Handling CLI Signals","text":"<p>Any process can receive signals to tell them a user (or the system) wants to shut them down allowing the process to terminate gracefully (1).</p> <ol> <li>This is the prevalent usage, but there are more.</li> </ol> <p>For example let's say you need to import a large csv file into a database but you want to be able to stop it gracefully. You can do:</p> <pre><code>use Innmind\\Signals\\Signal;\nuse Innmind\\Filesystem\\{\n    File,\n    File\\Content\\Line,\n    Name,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Immutable\\{\n    Sequence,\n    Predicate\\Instance,\n};\n\n$signaled = false;\n$stop = static function() use (&amp;$signaled): void {\n    $signaled = true;\n};\n\n$os\n    -&gt;process()\n    -&gt;signals()\n    -&gt;listen(Signal::interrupt, $stop);\n\n$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('data/'))\n    -&gt;unwrap()\n    -&gt;get(Name::of('users.csv'))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;map(static fn(File $file) =&gt; $file-&gt;content()-&gt;lines())\n    -&gt;toSequence() #(1)\n    -&gt;flatMap(static fn(Sequence $lines) =&gt; $lines)\n    -&gt;takeWhile(static function() use (&amp;$signaled) {\n        return !$signaled;\n    })\n    -&gt;foreach(static fn(Line $line) =&gt; importToDb($line));\n\n$os\n    -&gt;process()\n    -&gt;signals()\n    -&gt;remove($stop);\n</code></pre> <ol> <li><code>Maybe&lt;Sequence&gt;-&gt;toSequence()-&gt;flatMap(fn($sequence) =&gt; $sequence)</code> is a way to swallow the fact that the file may not exist.</li> </ol> <p>This way if a user sends a signal to interrupt the script, it will:</p> <ul> <li>pause the execution</li> <li>call the <code>$stop</code> function</li> <li>modify the <code>$signaled</code> flag</li> <li>resume the execution</li> <li>the next line that is attempted to be read won't be done because of <code>takeWhile</code></li> </ul> Tip <p>You can specify multiple listeners for a single signal and they'll be executed in the order you added them.</p>"},{"location":"getting-started/operating-system/processes/","title":"Launching Processes","text":""},{"location":"getting-started/operating-system/processes/#usage","title":"Usage","text":"<pre><code>use Innmind\\Server\\Control\\Server\\{\n    Command,\n    Process\\Success,\n    Process\\TimedOut,\n    Process\\Failed,\n    Process\\Signaled,\n};\n\n$process = $os\n    -&gt;control()\n    -&gt;processes()\n    -&gt;execute(\n        Command::foreground('apt-get')\n            -&gt;withArgument('install')\n            -&gt;withArgument('cowsay')\n            -&gt;withShortOption('y'),\n    )\n    -&gt;unwrap();\n$process\n    -&gt;wait()\n    -&gt;match(\n        static fn(Success $success) =&gt; doStuff(),\n        static fn(TimedOut|Failed|Signaled $error) =&gt; throw new RuntimeException();\n    );\n</code></pre> <p>This example waits for the installation of <code>cowsay</code> before continuing via <code>doStuff()</code> or it will fail with an exception.</p> Note <p>By default the process is executed with no environment variables. If you try to execute a command that is reachable only because you modified your <code>$PATH</code> environment variable, you'll need to specify it via <code>Command::foreground('command')-&gt;withEnvironment('$PATH', 'your path value')</code>.</p> <p>This may seem restrictive at first but it's done to force your program to be explicit. And it will help other developers to understand what's needed for the command to be run.</p> Info <p>If you don't want to wait for a process to finish you can replace <code>Command::foreground()</code> by <code>Command::background()</code> and remove the code <code>$process-&gt;wait()</code>.</p> <p>If you dont't really care about the process failing or not and simply want to forward its output you can use:</p> <pre><code>use Innmind\\Server\\Control\\Server\\Process\\Output\\{\n    Chunk,\n    Type,\n};\nuse Innmind\\Immutable\\Str;\n\n$process\n    -&gt;output()\n    -&gt;foreach(static function(Chunk $chunk): void {\n        // $chunk-&gt;type() is either Type::output or Type::error\n        echo $chunk-&gt;data()-&gt;toString();\n    });\n</code></pre> <p>This code will print the output of the underlying process in real time. The <code>foreach</code> call will return when the process is finished.</p> Tip <p>If you still need to check the result of the process you can still call <code>$process-&gt;wait()</code>, it will immediately return the result.</p> <p>You can also send content to the <code>STDIN</code> of the process via:</p> <pre><code>use Innmind\\Filesystem\\File\\Content;\nuse Innmind\\Immutable\\Monoid\\Concat;\n\necho $os\n    -&gt;control()\n    -&gt;processes()\n    -&gt;execute(\n        Command::foreground('echo')\n            -&gt;withInput(Content::ofString('some input')),\n    )\n    -&gt;unwrap()\n    -&gt;output()\n    -&gt;map(static fn(Chunk $chunk) =&gt; $chunk-&gt;data())\n    -&gt;fold(new Concat)\n    -&gt;toString();\n</code></pre> <p>The input can be any valid <code>Content</code> object, even lazy ones.</p>"},{"location":"getting-started/operating-system/processes/#streaming","title":"Streaming","text":"<p>By default the process output is kept in memory so you can use it multiple times. However for some commands the output can be quite large and it won't fit in memory.</p> <p>For example you want to run an archive command that you want to stream to the output.</p> <pre><code>$os\n    -&gt;control()\n    -&gt;processes()\n    -&gt;execute(\n         Command::foreground('zip')\n            -&gt;withShortOption('q')\n            -&gt;withShortOption('r')\n            -&gt;withArgument('-')\n            -&gt;withArgument('some folder/')\n            -&gt;streamOutput(),\n    )\n    -&gt;unwrap()\n    -&gt;output()\n    -&gt;foreach(static function(Chunk $chunk) {\n        echo $chunk-&gt;data()-&gt;toString();\n    });\n</code></pre> <p>You won't be able to reuse the output twice, if you try it will throw a <code>\\LogicException</code>.</p> Info <p>However if you've walked over the whole output you can still call <code>$process-&gt;wait()</code> to check if there was an error or not.</p>"},{"location":"getting-started/operating-system/processes/#ssh","title":"SSH","text":"<p>You can execute commands on a remote machine through SSH the same way you'd do it on the local machine via:</p> <pre><code>use Innmind\\Url\\Url;\n\n$process = $os\n    -&gt;remote()\n    -&gt;ssh(Url::of('ssh://user@machine-name-or-ip:22/'))\n    -&gt;processes()\n    -&gt;execute(\n        Command::foreground('apt-get')\n            -&gt;withArgument('install')\n            -&gt;withArgument('cowsay'),\n    )\n    -&gt;unwrap();\n</code></pre> <p>You can't specify the password to connect to the machine via the url. It's done to force you to use SSH keys.</p> Info <p>For now it's not possible to use an input when running commands through SSH.</p>"},{"location":"getting-started/operating-system/sql/","title":"SQL","text":"<p>The SQL client is structured by 2 concepts: immutable <code>Query</code> objects as input and <code>Sequence</code>s of immutable <code>Row</code>s as output.</p>"},{"location":"getting-started/operating-system/sql/#usage","title":"Usage","text":"<pre><code>use Formal\\AccessLayer\\{\n    Query\\SQL,\n    Row,\n};\nuse Innmind\\Url\\Url;\n\n$sql = $os\n    -&gt;remote()\n    -&gt;sql(Url::of('mysql://user:password@127.0.0.1:3306/database_name'));\n\n$sql(SQL::of('SELECT * FROM users'))-&gt;foreach(\n    static fn(Row $row) =&gt; var_dump($row-&gt;toArray()),\n);\n</code></pre>"},{"location":"getting-started/operating-system/sql/#prepared-queries","title":"Prepared queries","text":"<p>If you need to inject data in your queries you should use parameters.</p> <p>Do not use string concatenation as it can lead to SQL injection.</p> <pre><code>use Formal\\AccessLayer\\Query\\Parameter;\n\n$query = SQL::of('INSERT INTO users VALUES (:id, :username)')\n    -&gt;with(Parameter::named('id', 'some-id'))\n    -&gt;with(Parameter::named('username', 'some-username'));\n\n$sql($query);\n</code></pre> <p>Here named parameters are used via the format <code>:parameter_name</code> with the named specified again in <code>Paramater::named()</code>.</p> <p>You can also bind parameters by indices via the format <code>?</code> and then <code>Parameter::of('value')</code>. This way you don't duplicate strings, but the order you add the parameters via the <code>with</code> method matters.</p>"},{"location":"getting-started/operating-system/sql/#query-builder","title":"Query builder","text":"<p>The <code>SQL</code> class allows you to specify the exact query you want to execute. But if you want to generate queries programmatically you should use the other classes from the <code>Formal\\AccessLayer\\Query\\</code> namespace, such as <code>Select</code> or <code>Insert</code>.</p> SelectInsertetc... <pre><code>use Formal\\AccessLayer\\{\n    Query\\Select,\n    Table\\Name,\n    Table\\Column,\n};\n\n$select = Select::from(Name::of('users'))-&gt;columns( #(1)\n    Column\\Name::of('id'),\n    Column\\Name::of('username'),\n);\n\n$sql($select);\n</code></pre> <ol> <li>If you don't specify the columns it will retrieve them all by default.</li> </ol> <pre><code>use Formal\\AccessLayer\\{\n    Query\\Insert,\n    Row,\n};\n\n$insert = Insert::into(\n    Name::of('users'),\n    Row::of([\n        'id' =&gt; 'id-1',\n        'username' =&gt; 'john',\n    ]),\n    Row::of([\n        'id' =&gt; 'id-2',\n        'username' =&gt; 'jane',\n    ]),\n    // etc...\n);\n\n$sql($insert);\n</code></pre> <p>Other query builders include:</p> <ul> <li><code>CreateTable</code></li> <li><code>DropTable</code></li> <li><code>Delete</code></li> <li><code>Update</code></li> </ul>"},{"location":"getting-started/operating-system/sql/#filtering","title":"Filtering","text":"<p>When selecting from a table you can restrict the rows by specifying them manually in the <code>SQL</code> class. But if you need to programmatically construct the where clause you can use the specification pattern via the <code>Select</code> class.</p> <p>For example let's say you want to retrieve all users whose username starts with <code>a</code>. The first step is to create a specification:</p> <pre><code>use Innmind\\Specification\\{\n    Comparator\\Property,\n    Sign,\n};\n\nfinal class Username\n{\n    /** @psalm-pure */\n    public static function startsWith(string $value): Property\n    {\n        return Property::of(\n            'username', #(1),\n            Sign::startsWith,\n            $value,\n        );\n    }\n}\n</code></pre> <ol> <li>This is the column name.</li> </ol> <p>And then you use it like this:</p> <pre><code>$select = Select::from(Name::of('users'))\n    -&gt;where(Username::startsWith('a'));\n\n$sql($select);\n</code></pre> <p>The big advantage of specifications is that you can easily compose them. For example if you want users starting with <code>a</code> or <code>b</code> you'd do <code>Username::startsWith('a')-&gt;or(Username::startsWith('b'))</code>; and if you want all except these ones you can chain a <code>-&gt;not()</code> to negate the whole condition.</p> <p>Another advantage is that this composition forces you to think about precedence of your conditions to reduce the risk of implicit behaviours.</p>"},{"location":"getting-started/operating-system/sql/#laziness","title":"Laziness","text":"<p>All the queries you've seen so far return deferred <code>Sequence</code>s meaning that the queries are executed immediately but the returned rows will be loaded (and kept) in memory when you use the returned sequence.</p> <p>For most queries this is fine. But if you want to select a large amount of data that may not fit in memory you should use lazy queries.</p> <p>To do so instead of using <code>SQL::of()</code>/<code>Select::from()</code> use <code>SQL::onDemand()</code>/<code>Select::onDemand()</code>.</p> <pre><code>$select = Select::onDemand(Name::of('users'));\n\n$sql($select)-&gt;foreach(\n    static fn(Row $row) =&gt; doStuff($row),\n);\n</code></pre> <p>With this even if the result contains a million rows there'll only be one at a time in memory.</p> Info <p>However this means that if you call <code>foreach</code> twice it will run the query twice. The returned rows may change between the 2 calls, if you need the results to be the same you can't use lazy queries!</p>"},{"location":"getting-started/operating-system/sql/#transactions","title":"Transactions","text":"<p>To run queries inside a transaction you need to run the corresponding sql queries like this:</p> <pre><code>use Formal\\AccessLayer\\Query\\{\n    StartTransaction,\n    Commit,\n    Rollback,\n};\n\ntry {\n    $sql(new StartTransaction);\n\n    // run your queries here\n\n    $sql(new Commit);\n} catch (\\Throwable $e) {\n    $sql(new Rollback);\n\n    throw $e;\n}\n</code></pre>"},{"location":"getting-started/orm/","title":"ORM","text":"<p>This ORM focuses on simplifying data manipulation.</p> <p>It can handle any amount of data by being memory safe and reduces the complexity of data lifecycle by using immutable objects.</p> Info <p>Its monadic design allows it to be compatible with Innmind's asynchronous context.</p>"},{"location":"getting-started/orm/#example","title":"Example","text":"<pre><code>use Formal\\ORM\\{\n    Manager,\n    Sort,\n};\nuse Innmind\\Url\\Url;\n\n$manager = Manager::sql(\n    $os\n        -&gt;remote()\n        -&gt;sql(Url::of('mysql://user:pwd@host:3306/database?charset=utf8mb4')),\n);\n$_ = $manager\n    -&gt;repository(YourAggregate::class)\n    -&gt;all()\n    -&gt;sort('someProperty', Sort::asc)\n    -&gt;drop(150)\n    -&gt;take(50)\n    -&gt;foreach(static fn(YourAggregate $aggregate) =&gt; doStuff($aggregate));\n</code></pre>"},{"location":"getting-started/orm/#tips","title":"Tips","text":"<p>Since it focuses on usage and not abstracting a persistence model this ORM allows 3 different persistence models:</p> <ul> <li>SQL</li> <li>Filesystem</li> <li>Elasticsearch</li> </ul>"},{"location":"getting-started/orm/#advanced-usage","title":"Advanced usage","text":"<p>Full documentation available here.</p>"},{"location":"getting-started/orm/development/","title":"Development","text":""},{"location":"getting-started/orm/development/#setup","title":"Setup","text":"<p>For this chapter we'll work with a <code>User</code> class that can have multiple <code>Address</code> objects.</p> <p>To keep things simple we'll work with an in memory persistence. You'll learn how to really persist them in the next chapter.</p> <pre><code>use Formal\\ORM\\Manager;\nuse Innmind\\Filesystem\\Adapter\\InMemory;\n\n$orm = Manager::filesystem(InMemory::emulateFilesystem()); #(1)\n</code></pre> <ol> <li>From this point on every time you see <code>$orm</code> it will come from this example.</li> </ol> <code>User</code><code>Address</code> <pre><code>use Formal\\ORM\\{\n    Id,\n    Definition\\Contains,\n};\nuse Innmind\\Immutable\\Set;\n\nfinal readonly class User\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     * @param Set&lt;Address&gt; $addresses\n     */\n    private function __construct(\n        private Id $id,\n        private string $username,\n        #[Contains(Address::class)] #(1)\n        private Set $addresses,\n    ) {}\n\n    public static function new(string $username): self\n    {\n        return new self(\n            Id::new(self::class),\n            $username,\n            Set::of(),\n        );\n    }\n\n    public function addAdress(Address $address): self\n    {\n        return new self(\n            $this-&gt;id,\n            $this-&gt;username,\n            $this-&gt;addresses-&gt;add($address),\n        );\n    }\n}\n</code></pre> <ol> <li>This allows the ORM to know how to persist the data inside the collection.</li> </ol> <p>A <code>User</code> is called an aggregate in this ORM. This is the root object that have ownership of every data inside it (more on that below).</p> <p>An aggregate must have an <code>Id $id</code> property. All the other properties will be automatically stored if the ORM understands the type defined on the property.</p> Info <p>A <code>Set</code> is an immutable unsorted collection of unique objects.</p> <pre><code>final readonly class Address\n{\n    public function __construct(\n        private string $street,\n        private string $zipcode,\n        private string $city,\n    ) {}\n}\n</code></pre> <p>An <code>Address</code> is called an entity in this ORM. As you can see it doesn't have any id. The ORM knows an object of this class belongs to a given user because it is found inside its <code>$addresses</code> property.</p> <p>Of course nothing prevents you to add your own id to an entity, but the ORM will treat it as any other property.</p>"},{"location":"getting-started/orm/development/#persisting-a-new-aggregate","title":"Persisting a new aggregate","text":"<pre><code>use Innmind\\Immutable\\Either;\n\n$repository = $orm-&gt;repository(User::class);\n$orm-&gt;transactional(\n    static function() use ($repository) {\n        $repository-&gt;put(User::new('john'))-&gt;unwrap();\n        $repository-&gt;put(User::new('jane'))-&gt;unwrap();\n\n        return Either::right(null);\n    },\n);\n</code></pre> <p>In order to persist aggregates you need to first access their repository. You can think of this <code>$repository</code> as a persistent collection of all your objects for a given class.</p> <p>To modify (1) any data it has to be done in a transaction via <code>$orm-&gt;transactional()</code>. This is done to make sure your program is structurally correct. If you try to modify the data outside it will throw an exception, this prevents unforeseen modifications outside of the context you expect. Note that this applies to calls on a repository methods, not the aggregate objects.</p> <ol> <li><code>$repository-&gt;put()</code> or <code>$repository-&gt;remove()</code></li> </ol> <p>The function passed to <code>transactional</code> has to return an <code>Either</code>. If it contains a value on the right side then it will commit the transaction and if it contains a value on the left side (or throws an exception) it will rollback the transaction. The <code>transactional</code> method will return the <code>Either</code> as you'd expect.</p> <p>In our case we return <code>null</code> on the right side as we don't have any business logic that can fail.</p> <p>Let's say now that we want to create 2 users that live in the same city:</p> <pre><code>$address = new Address('somewhere', '75001', 'Paris');\n$john = User::new('john')-&gt;addAddress($address);\n$jane = User::new('jane')-&gt;addAddress($address);\n\n$repository = $orm-&gt;repository(User::class);\n$orm-&gt;transactional(\n    static function() use ($repository, $john, $jane) {\n        $repository-&gt;put($john)-&gt;unwrap();\n        $repository-&gt;put($jane)-&gt;unwrap();\n\n        return Either::right(null);\n    },\n);\n</code></pre> <p>Even though we use the same <code>Address</code> object for both users the address will be stored twice. This is possible because the <code>Address</code> is an immutable object that represents data, the object reference has no relevance for the ORM.</p> <p>This design as a HUGE benefit: you can't mess up your objects relations.</p>"},{"location":"getting-started/orm/development/#retrieving-an-aggregate","title":"Retrieving an aggregate","text":"<p>Once you persisted an aggregate you'll need to retrieve it, which is pretty straight forward:</p> <pre><code>$repository\n    -&gt;get(Id::of(User::class, 'some-uuid'))\n    -&gt;match(\n        static fn(User $user) =&gt; doStuff($user),\n        static fn() =&gt; userDoesntExist(),\n    );\n</code></pre> <p>You should replace <code>'some-uuid'</code> with the string representation of and id (via the <code>toString</code> method).</p> <p>Since the user you're asking for may not exist in the storage, the repository returns a <code>Maybe&lt;User&gt;</code> so you're forced to handle both cases.</p>"},{"location":"getting-started/orm/development/#modifying-an-aggregate","title":"Modifying an aggregate","text":"<p>To modify an aggregate you need to re-add it to the repository since the objects are immutable.</p> <pre><code>$orm-&gt;transactional(\n    static function() use ($repository) {\n        $_ = $repository\n            -&gt;get(Id::of(User::class, 'some-uuid'))\n            -&gt;map(static fn(User $user) =&gt; $user-&gt;addAddress(\n                new Address('somewhere', 'SW9 9SL', 'London'),\n            ))\n            -&gt;match(\n                static fn(User $user) =&gt; $repository-&gt;put($user)-&gt;unwrap(),\n                static fn() =&gt; null,\n            );\n\n        return Either::right(null);\n    },\n);\n</code></pre> <p>The benefit here is that you can't persist data by accident. All modifications to the persistence are explicit.</p>"},{"location":"getting-started/orm/development/#deleting-an-aggregate","title":"Deleting an aggregate","text":"<pre><code>$orm-&gt;transactional(\n    static function() use ($repository) {\n        $repository-&gt;remove(Id::of(User::class, 'some-uuid'))-&gt;unwrap();\n\n        return Either::right(null);\n    },\n);\n</code></pre> <p>Whether any aggregate with this id existed or not it will return nothing and won't throw an exception.</p>"},{"location":"getting-started/orm/development/#retrieving-a-collection-of-aggregates","title":"Retrieving a collection of aggregates","text":"<p>The simplest way is to retrieve all aggregates:</p> <pre><code>$repository\n    -&gt;all()\n    -&gt;foreach(static fn(User $user) =&gt; doStuff($user));\n</code></pre> <p>Even if you have thousands of aggregates in your storage this code will work because the ORM keeps track of an aggregate as long as you keep it in memory.</p> <p>Usually you won't want to retrieve all aggregates, you need only a subset. You could use <code>$repository-&gt;all()-&gt;filter()</code> but this is fairly innefficient as it retrieve all aggregates and throw out the ones you don't use.</p> <p>The best approach is to filter directly at the storage level. You do this via the specification pattern.</p> <p>Let's say we want all users with an address in <code>London</code>. First we need to build a specification:</p> <pre><code>use Innmind\\Specification\\{\n    Comparator\\Property,\n    Sign,\n};\n\nfinal class City\n{\n    /** @psalm-pure */\n    public static function of(string $city): Property\n    {\n        return Property::of(\n            'city', #(1)\n            Sign::equality,\n            $city, #(2)\n        );\n    }\n}\n</code></pre> <ol> <li>This is the name of the property in the <code>Address</code> class.</li> <li>This type has to be the same as the one on the property.</li> </ol> <p>And you use it like this:</p> <pre><code>use Formal\\ORM\\Specification\\Child;\n\n$repository\n    -&gt;matching(Child::of(\n        'addresses', #(1)\n        City::of('London'),\n    ))\n    -&gt;foreach(static fn(User $user) =&gt; doStuff($user));\n</code></pre> <ol> <li>This is the property name on the <code>User</code> class.</li> </ol> <p>And if you want to target <code>London</code> or <code>Paris</code> you can do <code>City::of('London')-&gt;or(City::of('Paris'))</code>.</p> <p>This is the same approach as the pure SQL one. So you can more easily upgrade from one to the other.</p> <p>You can of course also limit the number of aggregates to retrieve via <code>$repository-&gt;matching($specification)-&gt;drop($x)-&gt;take($y)</code>.</p>"},{"location":"getting-started/orm/development/#custom-types","title":"Custom types","text":"<p>So far you've only seen how to persist <code>string</code> properties. But you can use your own types.</p> <p>For example let's you want to create a <code>Username</code> class to prevent using empty usernames.</p> <pre><code>final readonly class Username\n{\n    private string $value;\n\n    public function __construct(string $value)\n    {\n        if ($value === '') {\n            throw new \\DomainException;\n        }\n\n        $this-&gt;value = $value;\n    }\n\n    public function toString(): string\n    {\n        return $this-&gt;value;\n    }\n}\n</code></pre> <p>Now you need to update the aggregate:</p> <pre><code>use Formal\\ORM\\{\n    Id,\n    Definition\\Contains,\n};\nuse Innmind\\Immutable\\Set;\n\nfinal readonly class User\n{\n    /**\n     * @param Id&lt;self&gt; $id\n     * @param Set&lt;Address&gt; $addresses\n     */\n    private function __construct(\n        private Id $id,\n        private Username $username,\n        #[Contains(Address::class)]\n        private Set $addresses,\n    ) {}\n\n    public static function new(Username $username): self\n    {\n        return new self(\n            Id::new(self::class),\n            $username,\n            Set::of(),\n        );\n    }\n\n    public function addAdress(Address $address): self\n    {\n        return new self(\n            $this-&gt;id,\n            $this-&gt;username,\n            $this-&gt;addresses-&gt;add($address),\n        );\n    }\n}\n</code></pre> <p>The last part is to tell the ORM how to convert this type. You need to create a class implementing the <code>Type</code> interface.</p> <pre><code>use Formal\\ORM\\Definition\\Type;\n\n/**\n * @psalm-immutable\n * @implements Type&lt;Username&gt;\n */\nfinal class UsernameType implements Type\n{\n    public function normalize(mixed $value): null|string|int|bool\n    {\n        return $value-&gt;toString();\n    }\n\n    public function denormalize(null|string|int|bool $value): mixed\n    {\n        if (!\\is_string($value)) {\n            throw new \\LogicException;\n        }\n\n        return new Username($value);\n    }\n}\n</code></pre> <ol> <li>This is what tells the ORM the type this class supports converting.</li> </ol> Tip <p>You don't need to handle the <code>null</code> value in your type, the ORM already does that for you.</p> <p>And you register this class when creating the ORM:</p> <pre><code>use Formal\\ORM\\{\n    Manager,\n    Definition\\Aggregates,\n    Definition\\Types,\n    Definition\\Type\\Support,\n};\nuse Innmind\\Filesystem\\Adapter\\InMemory;\n\n$orm = Manager::filesystem(\n    InMemory::emulateFilesystem(),\n    Aggregates::of(Types::of(\n        Support::class(Username::class, new Username),\n    )),\n);\n</code></pre>"},{"location":"getting-started/orm/production/","title":"Production","text":""},{"location":"getting-started/orm/production/#choose-the-right-storage","title":"Choose the right storage","text":"<p>Now that you know how to use the main features of this ORM, it's time to really persist the data.</p> <p>As said in the introduction you have 3 options:</p> <ul> <li>SQL</li> <li>Elasticsearch</li> <li>Filesystem</li> </ul> <p>If you need a reliable storage you should use SQL as it's battle proven.</p> <p>If you're trying to build a proof of concept then it's probable not necessary to use any third party storage and go with the filesystem.</p> <p>If you need efficiency when searching for your aggregates then you should go with Elasticsearch.</p> <p>The 3 storages are tested against the same properties. This means that the behaviour between all of them will be the same. So you can switch between them.</p>"},{"location":"getting-started/orm/production/#sql","title":"SQL","text":""},{"location":"getting-started/orm/production/#setup","title":"Setup","text":"<pre><code>use Formal\\ORM\\Manager;\nuse Innmind\\Url\\Url;\n\n$connection = $os\n    -&gt;remote()\n    -&gt;sql(Url::of('mysql://user:password@127.0.0.1:3306/database'));\n$orm = Manager::sql($connection);\n</code></pre> <p>The rest of your code doesn't have to change.</p>"},{"location":"getting-started/orm/production/#creating-the-tables","title":"Creating the tables","text":"<p>In order to persist your data you first need to create the tables where they'll be stored.</p> <pre><code>$aggregates = Aggregates::of(Types::default()); #(1)\n$show = ShowCreateTable::of($aggregates);\n\n$_ = $show(User::class)-&gt;foreach($connection); #(2)\n</code></pre> <ol> <li>Don't forget to also declare your own types here.</li> <li>You don't need to specify the entities here, only the aggregates class.</li> </ol> <p>This code automatically execute the queries to create the tables. You could instead print them (1) and store them in a database migration tool.</p> <ol> <li><code>$_ = $show(User::class)-&gt;foreach(var_dump(...));</code></li> </ol> Tip <p>You can use <code>formal/migrations</code> to run your migrations.</p>"},{"location":"getting-started/orm/production/#elasticsearch","title":"Elasticsearch","text":"<p>You first need to run an Elasticsearch instance, head to their documentation to learn how to start one.</p> <p>Then change the adapter of the manager:</p> <pre><code>use Formal\\ORM\\Adapter\\Elasticsearch;\nuse Innmind\\Url\\Url;\n\n$orm = Manager::of(\n    Elasticsearch::of(\n        $os-&gt;remote()-&gt;http(),\n        Url::of('http://localhost:9200/'), #(1)\n    ),\n);\n</code></pre> <ol> <li>If you use a local instance you can omit this parameter.</li> </ol> Tip <p>If you want to run tests against a real instance of Elasticsearch you should decorate the HTTP client like this:</p> <pre><code>use Formal\\ORM\\Adapter\\Elasticsearch\\Refresh;\n\nElasticsearch::of(Refresh::of(\n    $os-&gt;remote()-&gt;http(),\n));\n</code></pre> <p>This decorator makes sure each modification to the index are applied instantaneously. DO NOT use this decorator in production as it will overload your instance.</p> <p>Finally you need to create the index:</p> <pre><code>use Formal\\ORM\\{\n    Definition\\Aggregates,\n    Definition\\Types,\n    Adapter\\Elasticsearch\\CreateIndex,\n};\nuse Innmind\\Url\\Url;\n\n$aggregates = Aggregates::of(Types::default()); #(1)\n$createIndex = CreateIndex::of(\n    $os-&gt;remote()-&gt;http(),\n    $aggregates,\n    Url::of('http://localhost:9200/'),\n);\n\n$_ = $createIndex(User::class)-&gt;match(\n    static fn() =&gt; null,\n    static fn() =&gt; throw new \\RuntimeException('Failed to create index'),\n);\n</code></pre> <ol> <li>Don't forget to also declare your own types here.</li> </ol> Warning <p>Unlike other storages Elasticsearch doesn't support transactions.</p> <p>Elasticsearch also doesn't allow to list more than 10k aggregates, this means that if you store more than that you won't be able to list them all in a single <code>Sequence</code>. You'll need to use explicit search queries to find them all back.</p>"},{"location":"getting-started/orm/production/#filesystem","title":"Filesystem","text":""},{"location":"getting-started/orm/production/#local","title":"Local","text":"<p>This is the best storage when starting to develop a new program as there's no schema to update. This allows for rapid prototyping.</p> <pre><code>use Innmind\\Url\\Path;\n\n$orm = Manager::filesystem(\n    $os\n        -&gt;filesystem()\n        -&gt;mount(Path::of('path/where/to/store/data')),\n);\n</code></pre> <p>And... that's it.</p>"},{"location":"getting-started/orm/production/#s3","title":"S3","text":"<p>You should this storage for small programs without much concurrency that you need to synchronise for multiple clients. A good example is a CLI program that you want to work across multiple machines.</p> <p>First you need to require the S3 package:</p> <pre><code>composer require innmind/s3 '~5.0'\n</code></pre> <p>Then configure the ORM:</p> <pre><code>use Innmind\\S3\\{\n    Factory,\n    Region,\n    Filesystem,\n};\nuse Innmind\\Url\\Url;\n\n$bucket = Factory::of($os)-&gt;build(\n    Url::of('https://acces_key:acces_secret@bucket-name.s3.region-name.scw.cloud/'),\n    Region::of('region-name'),\n);\n$orm = Manager::filesystem(\n    Filesystem\\Adapter::of($bucket),\n);\n</code></pre>"},{"location":"getting-started/orm/testing/","title":"Testing","text":""},{"location":"getting-started/orm/testing/#guarantees","title":"Guarantees","text":"<p>When it comes to testing your program a question arises: should you use the same kind of database than in production or use a faster implementation to speed up the test suite.</p> <p>When using ORMs that let the SQL bleed through their APIs this question becomes tricky because you may not end up having the same behaviour between your tests and in production.</p> <p>This ORM doesn't have such problem. It uses Property Based Testing to make sure all storage implementations behave the same way.</p> <p>This means that you can safely use a faster storage for your tests and it will behave the same way as in production.</p>"},{"location":"getting-started/orm/testing/#setup","title":"Setup","text":""},{"location":"getting-started/orm/testing/#filesystem","title":"Filesystem","text":"<p>You should use an in memory filesystem for your tests as it's the fastest since it never writes to the actual filesystem. And since the data is isolated to the process, you could run your tests in parallel thus speeding up even more your test suite.</p> <pre><code>use Formal\\ORM\\Manager;\nuse Innmind\\Filesystem\\Adapter\\InMemory;\n\n$adapter = InMemory::emulateFilesystem();\n$orm = Manager::filesystem($adapter);\n</code></pre> <p>Your aggregates will be kept in memory as long as there is a reference to <code>$adapter</code>. This means that if your test looks something like this it won't work:</p> <pre><code>$orm = Manager::filesystem(InMemory::emulateFilesystem());\n\n// do some work that creates aggregates\n\n$orm = Manager::filesystem(InMemory::emulateFilesystem());\n\n// run expectations on your aggregates\n</code></pre> <p>The second instanciation of <code>$orm</code> will free the first one from memory and your aggregates will disappear.</p>"},{"location":"getting-started/orm/testing/#elasticsearch","title":"Elasticsearch","text":"<p>In case you want test a concrete instance of Elasticsearch to replicate the exact behaviour as in production, you should change one line when creating the orm:</p> <pre><code>use Formal\\ORM\\{\n    Manager,\n    Adapter\\Elasticsearch,\n    Adapter\\Elasticsearch\\Refresh,\n};\n\n$orm = Manager::of(\n    Elasticsearch::of(\n        Refresh::of(\n            $os-&gt;remote()-&gt;http(),\n        ),\n    ),\n);\n</code></pre> <p>This decorator will make sure that every modification to an index is applied immediately. The default behaviour of Elasticsearch is that it will put the modification in an internal queue and there's at least a 1 second delay before seeing the change in the index. This is fine in production but it's difficult to do some assertions in a test.</p> <p>If you need to assert you can fetch an aggregate after persisting it, then this decorator is for you.</p>"},{"location":"philosophy/","title":"Philosophy","text":"<p>The ultimate goal of this organization is to verify Antonio Damasio's theory of consciousness<sup>1</sup>.</p> <p>While this objective doesn't directly matter for your projects it structures this ecosystem in a big way:</p> <p>Innmind itself tries to solve a problem.</p> <p>This is why all the packages fits together to help solve bigger and bigger problems. It also means it won't go away while the goal is not reached. And since the goal may even not be reachable, Innmind is here to stay!</p> <p>This also enforces 2 things. Abstractions need to be extremely robust to safely build higher abstractions. And they need to be reusable outside this project (to avoid being wasted in case the goal is not reachable).</p> <p>All the following chapters will describe the principles behind the abstractions robustness.</p> <ol> <li> <p>You can learn more in this french article.\u00a0\u21a9</p> </li> </ol>"},{"location":"philosophy/abstractions/","title":"Abstractions","text":"<p>All maps are wrong... but some are useful.</p> <p>For a map to be useful it has to be wrong. For a map to be right it has to represent with exactitude the world, meaning it has to be the size of the world it represent. Such map has no use as it doesn't simplify our task.</p> <p>A map's aim is to shrink the information to the minimum for us to accomplish our task. This means that the level of information must depend on our task. You won't take the same map for a road trip or a hike.</p> <p>Abstractions are the same.</p> <p>An abstraction that tries to represent all the information it tries to abstract fails in its mission. In the end you end up with the same information but expressed in a different way.</p> <p>This means that for an abstraction to be useful it must omit information.</p> <p>Then comes the need to choose which information to keep and the appropriate semantic for the task.</p> <p>This also means that an abstraction can't fit all tasks and you may not be able to use it. But this is ok, not everyone has to speak the same language; you just need to find the vocabulary that fits your need.</p> <p>Innmind doesn't try to fit everybody's need (1).</p> <ol> <li>As you'll find with the filesystem abstraction or the ORM.</li> </ol> Note <p>But keep in mind that semantics change and vocabularies expand.</p>"},{"location":"philosophy/capabilities/","title":"Capabilities","text":"<p>Ambient authority is the ability to call the system (1) from anywhere in your program.</p> <ol> <li>such as <code>fopen</code></li> </ol> <p>On the other hand Capabilities is a way to represent a resource we have access to, and is given to us. We cannot access it directly.</p> <p>These designs are security models inside programs.</p> <p>Innmind focuses more on the system access side more than the security one.</p> <p>In essence the capabilities approach is about dependency injection on all things concerning the operating system.</p> <p>That's why the Operating System abstraction is central in the ecosystem.</p>"},{"location":"philosophy/development/","title":"Development Process","text":""},{"location":"philosophy/development/#type-strictness","title":"Type strictness","text":"<p>All packages use Psalm on the strictess level to make sure there won't be type errors.</p> <p>To make sure you use Innmind correctly you should use it as well.</p>"},{"location":"philosophy/development/#versioning","title":"Versioning","text":"<p>All packages use Semver to release new versions.</p> <p>All minor and bugfix versions are backward compatible and try as much as possible to not change your program's behaviour. Most updates bring new code that you have to choose to use it (or not).</p> <p>Major updates break the API.</p> <p>Changelogs and the type system will help you through all changes.</p>"},{"location":"philosophy/development/#make-it-easy-to-use-it-right","title":"Make it easy to use it right","text":"<p>and make it difficult to use it wrong.</p> <p>This summarizes all the previous chapters.</p> <p>To reach this all packages go through the same iteration loop:</p> <ul> <li>make it work</li> <li>make it simple</li> <li>make it fast</li> </ul> Note <p>Though the last step has a lower priority than building new higher level abstractions.</p>"},{"location":"philosophy/explicit/","title":"Explicit","text":"<p>Implicit behaviours makes life easy for small programs. But as it grows and time passes it becomes more and more difficult to remember all of them and make sure they fit together.</p> <p>Innmind itself is a large project. That's why it tries to be as explicit as possible.</p> <p>By explicit ear the facts that:</p> <ul> <li>no code will have unforeseen global behaviour</li> <li>no package installation will automatically change a behaviour of a program</li> <li>you call Innmind code, not the other way around</li> </ul> <p>This means that to understand your program you can always go to the definition of the function you're using. You can traverse your whole program from entrypoint to low level calls to the system with this approach.</p> <p>Below you'll find some techniques that make Innmind explicit.</p>"},{"location":"philosophy/explicit/#parse-dont-validate","title":"Parse, don't validate","text":"<p>This is a reference to Alexis King's article.</p> <p>Validation is the process to check if a value respect a set of rules before using it. Take this example that may feel familiar:</p> <pre><code>$email = 'foo@example.com';\ncreateUser($email);\nsendWelcomeEmail($email);\n</code></pre> <p>Here both functions have to validate that the <code>string</code> passed as argument is indeed an email. The validation has to be done twice because the second function is unaware of the one done in the first function.</p> <p>Instead Parsing means to attach an information to the validated value. In other words encapsulate your data in an object.</p> <p>With parsing the example above becomes:</p> <pre><code>$email = new Email('foo@example.com');\ncreateUser($email);\nsendWelcomeEmail($email);\n</code></pre> <p>Now the validation is done by the <code>Email</code> class and will throw if the <code>string</code> is not an email. The following functions no longer have to do validation as they're guaranteed to have a valid email as argument.</p> <p>This is why you'll find a lot of classes in Innmind that only hold data, the classes name are important.</p> Exceptions to the rule <p>Note that they're some exceptions to this rule such as the <code>Sequence</code> not having a sister class <code>NonEmptySequence</code>. This class doesn't exist because it would make composition harder.</p>"},{"location":"philosophy/explicit/#constraints-liberate-liberties-constrain","title":"Constraints liberate, liberties constrain","text":"<p>This is a reference to Runar Bjarnason's talk.</p> <p>A constraint prevents us from doing some thing. Liberty is our ability to do what we want.</p> <p>The saying constraints liberate, liberties constrain then may seem contradictory. Yet us abiding by the law is just that. The law prevents us from harming another citizen, this constraint liberates us from having to worry about someone else trying to harm us and consequently free us to think about more productive activities.</p> <p>As developers we tend to want to do whatever we want in our programs. But this limits us in the level of abstractions we can use.</p> <p>Innmind chooses to apply constraints in order to build higher abstractions.</p>"},{"location":"philosophy/explicit/#closed-by-default","title":"Closed by default","text":"<p>This applies to 2 things: code and data.</p> <p>For a code to be closed usually means having <code>final</code> classes to prevent developer to use inheritance to modify the behaviour of a program, thus encouraging composition. The alternative is the use of functions that can only be composed.</p> <p>For data this means to be very restrictive when parsing.</p>"},{"location":"philosophy/explicit/#maintainability","title":"Maintainability","text":"<p>By having enough constraints it simplifies the maintainability of this ecosystem.</p> <p>All possible usages and possible values are known thanks to these constraints, meaning any modification can be safely released.</p>"},{"location":"philosophy/oop-fp/","title":"OOP &amp; FP","text":""},{"location":"philosophy/oop-fp/#oop","title":"OOP","text":"<p>Originally this paradigm was intended to represent the behaviour of living cells (objects) that interact with each other via message passing. Each cell/object is supposed to be a closed unit of compute.</p> <p>Innmind follows this principle by using closed (aka <code>final</code>) classes with no getter/setter method, each method express an action.</p> <p>There are 2 main kind of objects: the ones representing data with their associated behaviours (aka methods) and the ones expressing actions (usually with only the <code>__invoke</code> method).</p> <p>The bigger idea of OOP mentioned by Alan Kay of message passing is fulfilled by the Actor Model.</p>"},{"location":"philosophy/oop-fp/#fp","title":"FP","text":"<p>This is a more mathematical approach to building programs that has gained a lot of traction for the past few years.</p> <p>Innmind mainly use the principles described below, but FP as a whole has a lot more.</p>"},{"location":"philosophy/oop-fp/#immutability","title":"Immutability","text":"<p>You already use immutable data without even realising it. For example if you do <code>$result = str_replace($search, $replace, $subject)</code>, the call of the function doesn't modify the values inside <code>$search</code>, <code>$replace</code> or <code>$subject</code> but returns a new value <code>$result</code>. This is in essence immutability, you only return new values.</p> <p>This allows to have less things to think about when calling a method. You know for sure the data you pass in to a function won't change. And inside a function you know that manipulating the data passed in won't have side effects outside of your scope.</p> <p>The immutability of data applies to primitive values but also to objects. A call to a method will return a new object, and the initial object it kept as is.</p> <p>Innmind uses immutable data everywhere possible.</p>"},{"location":"philosophy/oop-fp/#purity","title":"Purity","text":"<p>This concept applies to functions; may it be anonymous functions, named functions or methods.</p> <p>A function is considered pure if it has no side effects. A side effect may be altering state or doing I/O. This means that a function can't use a global variable, print something to the screen or read something from the filesystem.</p> <p>In other words a pure function only interacts with the immutable arguments passed in and returns an immutable value.</p> <p>Just like Immutability this allows to have less things to think about. By modifying/calling a pure function you know you won't break an unforeseen part of your program.</p>"},{"location":"philosophy/oop-fp/#totality","title":"Totality","text":"<p>A function is considered total if it can return a value for any combination of arguments it accepts.</p> <p>For example the function <code>divide(int, int): float</code> is not total because it will have to throw an exception for a division by <code>0</code>. On the other hand <code>divide(int, int): ?float</code> is total because it can return <code>null</code> in case of a division by <code>0</code>.</p> <p>The advantage of using total functions is that a static analysis tool can automatically check all the combinations to make sure your programm won't crash. It eliminates the need to write tests for the exceptions or the surprises of the runtime.</p> <p>Innmind heavily relies on this design to reduce the mental load of making sure every unhappy path is covered.</p> Exceptions <p>Innmind also relies on <code>Exception</code>s for cases where the program can't be recovered. But since it can't be recovered you don't have to think about them, that's also why they're not documented.</p> <p>It somewhat follows the <code>Let it crash</code> approach of Erlang.</p>"},{"location":"philosophy/oop-fp/#composition","title":"Composition","text":"<p>This allows to extend the behaviour of a function without knowing its implementation. And this is completely transparent for the caller of such functions.</p> <p>An example is an HTTP client (1) that provides a base implementation to do calls via <code>curl</code> and the <code>logger</code>, <code>followRedirections</code> and <code>circuitBreaker</code> decorators. You can compose them any way you wish:</p> <ol> <li>such as <code>innmind/http-transport</code></li> </ol> <ul> <li><code>logger(followRedirections(curl))</code> will only log the user calls and is unaware if the redirections are followed</li> <li><code>followRedirections(logger(curl))</code> will log the user calls and every redirections</li> <li><code>circuitBreaker(logger(curl))</code> will not log calls to a domain that has previously failed</li> <li>etc...</li> </ul> <p>The big advantage is that you can compose them locally depending on your needs (1).</p> <ol> <li>As opposed to the inheritance approach where you're limited by the statically defined combinations exposed.</li> </ol> <p>Innmind heavily uses composition to adapt behaviours locally and allows you to compose the base implementations the way you wish.</p> Info <p>The interesting discovery after many years of using composition with Innmind is that the higher the abstractions the more possibilities it offers.</p>"},{"location":"philosophy/oop-fp/#type-detonation","title":"Type detonation","text":"<p>This means computing a concrete value. But detonating too early exposes some problems.</p> <p>For example, the math operation of the square of the square root of a number should return the same number. But if the type is detonated at each function <code>square(squareRoot(2))</code> won't return <code>2</code>(1).</p> <ol> <li><code>sqrt(2)**2</code> will return <code>2.0000000000000004</code></li> </ol> <p>By not detonating too early the abstractions can do some optimisations on your behalf without even realising it (1). This is done by returning intermediate representations of the operations that needs to be done.</p> <ol> <li>For example <code>innmind/math</code> uses objects to represents numbers that optimise the <code>square(squareRoot(2))</code> in order to compute <code>2</code>. Or <code>innmind/http-transport</code> that can run requests concurrently.</li> </ol> <p>In essence this lazyness allows Innmind to optimise some operations.</p>"},{"location":"philosophy/oop-fp/#monads","title":"Monads","text":"<p>Monads are the culmination of the designs described above and are the cornerstone of this ecosystem.</p> <p>They're data structures classes with at least 2 methods: <code>map</code> and <code>flatMap</code>.</p> <ul> <li><code>map</code> will return a new monad of the same class with the data contained in it modified via the function passed to <code>map</code>.</li> <li><code>flatMap</code> is similar to <code>map</code> except that the function passed to it must return a monad.</li> </ul> <p>Said like this, monads are very abstract concepts. So here's an example of the simplest monad, the <code>Identity</code>:</p> Identity monadPlain old PHP <pre><code>$value = Identity::of(1)\n    -&gt;map(fn(int $value) =&gt; $value + 1)\n    -&gt;flatMap(fn(int $value) =&gt; Identity::of($value * 2))\n    -&gt;unwrap();\n$value === 4; // true\n</code></pre> <pre><code>$value = 1;\n$value = $value + 1;\n$value = $value * 2;\n$value === 4; // true\n</code></pre> <p>While this example may not seem to provide much value, these structures are extremly powerful as it will be shown in Getting started.</p> Type detonation <p>Detonating a monad means calling a method that returns something else than a monad.</p>"},{"location":"philosophy/oop-fp/#false-dichotomy","title":"False dichotomy","text":"<p>When choosing our tools we are usually presented 2 choices: Hype vs Boring technologies, OOP vs FP, etc... with the impression that we can only choose one.</p> <p>Innmind uses both OOP and FP to take advantages from both worlds.</p> <p>The easiness of combining data with associated methods and handling of mutable data (1) of OOP. The ease of mind of FP to only have to deal with the code in front of you (2).</p> <ol> <li>such as socket servers</li> <li>There's little chance to break the code on the other side of a program.</li> </ol>"},{"location":"philosophy/semantic/","title":"Semantic","text":""},{"location":"philosophy/semantic/#the-aim","title":"The aim","text":"<p>A good semantic allows to communicate an idea quickly by compressing the information. For example, the word cat caries a lot more information and in a more comprehensive way than a set of atoms forming a small 4 legged animal with whiskers.</p> <p>By establishing a good vocabulary it's possible to convey more and more complex information in a relatively constant space.</p>"},{"location":"philosophy/semantic/#this-is-not-code","title":"This is not code","text":"<pre><code>$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('folder/'))\n    -&gt;unwrap()\n    -&gt;get(Name::of('file'))\n    -&gt;keep(Instance::of(File::class))\n    -&gt;match(\n        static fn(File $file) =&gt; $file\n            -&gt;content()\n            -&gt;lines()\n            -&gt;foreach(static fn(Line $line) =&gt; echo $line-&gt;toString()),\n        static fn() =&gt; echo 'unknown file',\n    );\n</code></pre> <p>With this example we see that it's possible to understand the result of a program without knowing how it is executed.</p> <p>Code was initially a way to tell the machine the steps to follow to reach a result. But the more we move up through the abstractions (languages included) the farther away we get to tell the machine the exact steps.</p> <p>The more the abstractions the more we need to communicate with other developers in order to build programs.</p> <p>Code is now a formalised language between humans that has the side effect of being runnable by machines.</p>"},{"location":"philosophy/semantic/#declarative","title":"Declarative","text":"<p>Imperative code is telling the machine how to do things. While Declarative is telling what to do.</p> <p>A concrete example of this is the difference between an <code>array</code> and the <code>Sequence</code> monad. With an array it's easy to handle data as it's assigning values for indices, but it's not possible to handle an infinite stream of values (as it requires to use generators). On the other hand the <code>Sequence</code> only allows to describe the transitions the values must follow, you have no say on the way the values are assigned internally.</p> <p>This allows the <code>Sequence</code> to have multiple internal representations. It can work just like an <code>array</code> with the same assignment logic, or it can work with an infinite stream of values. The choice lies with the one creating the <code>Sequence</code>, any use of it is the same afterward.</p> <p>It's by this mechanism that this ecosystem can grow while keeping the complexity under control.</p>"},{"location":"philosophy/simplicity/","title":"Simplicity","text":""},{"location":"philosophy/simplicity/#complexity-vs-difficulty","title":"Complexity vs Difficulty","text":"<p>We tend to use simple and easy or difficult and complex interchangeably. But they're very much different.</p> <p>Complexity is an objective scale (1) of a number of parts of a system and the number of interactions between each part.</p> <ol> <li>with Simplicity being on one end of this scale</li> </ol> <p>Difficulty is a subjective scale related to your familiarity with a subject. By familiarity ear the number of times you've done some task.</p> <p>A general example of this difference is an electric circuit to light a bulb:</p> <ul> <li> <p>it is simple to use, you only need to be aware of the switch to light the bulb (1)</p> <ol> <li>even with many switches to light the same bulb the complexity is the same</li> </ol> </li> <li> <p>it is complex to build such circuit (1)</p> <ol> <li>especially with mutliple switches</li> </ol> </li> <li> <p>it is difficult for a child to build such circuit</p> </li> <li>it is easy for an electrician to build such circuit</li> </ul> <p>Innmind heavily leans toward simplicity. Even if at times it doesn't feel easy.</p>"},{"location":"philosophy/simplicity/#in-practice","title":"In practice","text":"<p>The Filesystem package was bitten (in an early version) for mistaking easyness by simplicity.</p> <p>The <code>Adapter</code> interface has a <code>get</code> method to return a file. Initially the argument passed to it was a <code>string</code> to represent the file name. But months later when building an S3 abstraction for this interface it wasn't clear if a path could be passed in the string.</p> <p>The easiness of using a <code>string</code> brought complexity to the implementation to make sure all adapters behave the same way. And also brought difficulty to the user when switching an adapter for another, having to deal with the inconsistencies.</p> <p>The <code>string</code> was later replaced by the a class named <code>Name</code>. Any <code>Adapter</code> implementation has to check its behaviour to understand what's possible, no need to be aware of other implementations anymore.</p> <p>You'll find all kind of classes in this ecosystem that encapsulate values to reach this kind of simplicity.</p>"},{"location":"testing/","title":"Testing","text":"<p>Testing is an important part of any project. In PHP the popular frameworks helps you test at different levels of abstraction with a variety of syntaxes. But they all work pretty much the same way: they help you test one particular scenario.</p> <p>Innmind uses the Property Based Testing technique.</p> <p>This helps bring higher and higher stable abstractions without the burden to write more scenarii manually.</p> <p><code>innmind/black-box</code> can help you bring this technique to your projects. You can start writing tests like you're used to and gradually move toward PBT.</p> <p>Innmind packages initially were tested with PHPUnit and now gradually move to BlackBox.</p>"},{"location":"testing/blackbox/","title":"BlackBox","text":"<p>This is Innmind's own testing framework.</p> <p>It follows Innmind's philosophy meaning it can be integrated in other tools. It is self contained and do not rely on global state.</p>"},{"location":"testing/blackbox/#installation","title":"Installation","text":"<pre><code>composer require --dev innmind/black-box '~6.5'\n</code></pre>"},{"location":"testing/blackbox/#setup","title":"Setup","text":"blackbox.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'vendor/autoload.php';\n\nuse Innmind\\BlackBox\\Application;\n\nApplication::new($argv) #(1)\n    -&gt;tryToProve(function() {\n        yield test(\n            'More on tests in the next chapter',\n            static fn($assert) =&gt; $assert-&gt;true(true),\n        );\n    })\n    -&gt;exit();\n</code></pre> <ol> <li>More on the usage of <code>$argv</code> below.</li> </ol> <p>This is the simplest setup of BlackBox. A PHP file (1) that bootstraps an <code>Application</code> to which is passed a function that will return a generator of tests and then exits.</p> <ol> <li>In this case the file is named <code>blackbox.php</code> but you can call it the way you want.</li> </ol> <p>And you simply run your tests via <code>php blackbox.php</code>.</p>"},{"location":"testing/blackbox/#organization","title":"Organization","text":"<p>In the example above the tests are provided inside an inline generator. This is fine when you only have a few of them. When it's no longer convenient you should split your tests in multiple files.</p> File 1File 2 proofs/file1.php<pre><code>&lt;?php\n\nreturn static function() {\n    yield test(\n        'Test 1',\n        static fn($assert) =&gt; $assert-&gt;true(true),\n    );\n}\n</code></pre> proofs/file2.php<pre><code>&lt;?php\n\nreturn static function() {\n    yield test(\n        'Test 2',\n        static fn($assert) =&gt; $assert-&gt;true(true),\n    );\n}\n</code></pre> <p>If you want to load these 2 files you can do:</p> blackbox.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'vendor/autoload.php';\n\nuse Innmind\\BlackBox\\Application;\n\nApplication::new($argv)\n    -&gt;tryToProve(function() {\n        yield from (require 'proofs/file1.php');\n        yield from (require 'proofs/file2.php');\n    })\n    -&gt;exit();\n</code></pre> <p>This is good because you can control the way your files are loaded. But adding new files becomes tedious, especially when multiple persons work on the project.</p> <p>Instead you can simplify it with:</p> blackbox.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'vendor/autoload.php';\n\nuse Innmind\\BlackBox\\{\n    Application,\n    Runner\\Load,\n};\n\nApplication::new($argv)\n    -&gt;tryToProve(Load::everythingIn('proofs/'))\n    -&gt;exit();\n</code></pre> <p>In the end you have full control over the order your tests are loaded.</p>"},{"location":"testing/blackbox/#tags","title":"Tags","text":"<p>After a while you may end up with a lot of tests and running them all all the time can be time consuming. You can categorize your tests via tags.</p> <p>You declare them this way:</p> <pre><code>use Innmind\\BlackBox\\Tag;\n\nyield test( #(1)\n    'Test name',\n    static fn($assert) =&gt; $assert-&gt;true(true),\n)-&gt;tag(Tag::positive, Tag::wip);\n</code></pre> <ol> <li>Refer to example above to know where to place a test.</li> </ol> <p>Then to only run a test with a given tag: <code>php blackbox.php wip</code>.</p> <p>The list of arguments you pass in the CLI command is passed to BlackBox via the code <code>Application::new($argv)</code>. Each argument must correspond to the name of a case on the <code>Innmind\\BlackBox\\Tag</code> enum.</p>"},{"location":"testing/proofs/","title":"Proofs","text":"<p>A proof<sup>1</sup> is a way to declare a behaviour for a range of values.</p> <p>Let's refactor the previous test:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n    Set,\n};\n\nApplication::new([])\n    -&gt;tryToProve(function() {\n        yield proof(\n            'add',\n            given(\n                Set::of(1),\n                Set::of(2),\n                Set::of(3),\n            ),\n            static fn(Assert $assert, int $a, int $b, int $expected) =&gt; $assert\n                -&gt;expected($expected)\n                -&gt;same(add($a, $b)),\n        );\n    })\n    -&gt;exit();\n</code></pre> <p>The most important part here is the <code>Set</code>s passed to <code>given</code>. A <code>Set</code> defines a range of values to generate a scenario. In this case we use 3 sets each containing a single value. Each <code>Set</code> parameter you add to <code>given</code> adds an argument to the test function.</p> <p>In essence this proof does exactly the same thing as the previous test.</p> <p>Now if we want to generate mutiple scenario:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n    Set,\n};\n\nApplication::new([])\n    -&gt;tryToProve(function() {\n        yield proof(\n            'add',\n            given(\n                Set::of(\n                    [1, 2, 3],\n                    [2, 3, 5],\n                ),\n            ),\n            static function(Assert $assert, array $case) {\n                [$a, $b, $expected] = $case;\n                $assert\n                    -&gt;expected($expected)\n                    -&gt;same(add($a, $b));\n            }\n        );\n    })\n    -&gt;exit();\n</code></pre> <p>This proof will run both <code>add(1, 2) === 3</code> and <code>add(2, 3) === 5</code>. But you don't want to specify all scenarii possible to prove the behaviour of this function.</p> <p>Instead you'd code the <code>add</code> properties like this:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n    Set,\n};\n\nApplication::new([])\n    -&gt;tryToProve(function() {\n        yield proof(\n            'add is commutative',\n            given(\n                Set::integers(),\n                Set::integers(),\n            ),\n            static fn(Assert $assert, int $a, int $b) =&gt; $assert-&gt;same(\n                add($a, $b),\n                add($b, $a),\n            ),\n        );\n        yield proof(\n            'add is cumulative',\n            given(\n                Set::integers(),\n                Set::integers(),\n                Set::integers(),\n            ),\n            static fn(Assert $assert, int $a, int $b, int $c) =&gt; $assert-&gt;same(\n                add($a, add($b, $c)),\n                add(add($a, $b), $c),\n            ),\n        );\n        yield proof(\n            '0 is an identity value',\n            given(Set::integers()),\n            static fn(Assert $assert, int $a) =&gt; $assert-&gt;same(\n                $a,\n                add($a, 0), #(1)\n            ),\n        );\n    })\n    -&gt;exit();\n</code></pre> <ol> <li>Where <code>0</code> is placed doesn't matter thanks to the commutative proof above.</li> </ol> <p>Each time you'll run these proofs BlackBox will run <code>100</code> scenarii per proof with different values each time. This way the more you run these proofs the more BlackBox explores the values space to try to find a specific combination that makes the <code>add</code> function fail.</p> <p>You should explore the <code>Innmind\\BlackBox\\Set\\</code> namespace to see all the values you can generate. <code>Set</code>s can be composed so you're not limited to primitive values, you can build pretty much any data structure.</p> Tip <p>Other packages can also expose <code>Set</code>s, you can find them on Packagist via the <code>innmind/black-box-sets</code> virtual package.</p> <ol> <li> <p>BlackBox use the term proof to emphasize that you are testing behaviours not specific scenarii, but these are NOT formal proofs.\u00a0\u21a9</p> </li> </ol>"},{"location":"testing/properties/","title":"Properties","text":"<p>Properties are proofs extracted as classes so that they can be run in a different context. More specifically they verify the behaviour of objects.</p> <p>The main goal of these properties is to make sure multiple implementations of a given system all behave the same way.</p> <p>The most prominent example in the Innmind ecosystem are the filesystem properties. <code>innmind/filesystem</code> has 2 implementations of its <code>Adapter</code> interface, a real implementation and an in memory one, and both implementations are tested against the same properties. <code>innmind/s3</code> also has implementation of <code>Adapter</code> and simply uses the filesystem properties to make sure implementations can be swapped by a user without a change in behaviour.</p> <p>The ORM also uses properties to make sure its 3 storage implementations behave exactly the same way.</p> <p>To learn more about them head to the BlackBox package documentation.</p>"},{"location":"testing/property-based-testing/","title":"Property Based Testing","text":""},{"location":"testing/property-based-testing/#description","title":"Description","text":"<p>Instead of writing tests like:</p> <p>When I run this code with this value X then I should get back the value Y.</p> <p>You'd do:</p> <p>When I run this code with any value of type X then this property (1) is true.</p> <ol> <li>Here property is used in the general sense, not as an object property.</li> </ol> <p>The advantage of writing tests this way is that we define the range of values that should make the test pass. It's then up to the framework to generate the values within this range and run your test multiple times to make sure the test pass.</p> <p>This means that the testing framework constantly run new scenarii for your tests. The more you run your tests the more confidence you have that your code is correct.</p> <p>The goal is to make sure your implementation is correct in all possible scenarii. And it also has the side effect to making your tests less brittle.</p>"},{"location":"testing/property-based-testing/#examples","title":"Examples","text":""},{"location":"testing/property-based-testing/#math-add-function","title":"Math <code>add</code> function","text":"<p>This is the go to example to introduce this technique as this function is easy to understand and only have 3 properties:</p> CommutativeCumulative<code>0</code> is an identity value <p>This means that you can change the order of arguments and still get the same result.</p> <p>In pseudo code a test would look like: <pre><code>function testCommutative(int $a, int $b) {\n    assertSame(\n        add($a, $b),\n        add($b, $a),\n    );\n}\n</code></pre></p> <p>This means that no matter the order of operations you still get the same result.</p> <p>In pseudo code a test would look like: <pre><code>function testCumulative(int $a, int $b, int $c) {\n    assertSame(\n        add($a, add($b, $c)),\n        add(add($a, $b), $c),\n    );\n}\n</code></pre></p> <p>This means that if you add <code>0</code> to any other value it returns the same value.</p> <p>In pseudo code a test would look like: <pre><code>function testIdentityValue(int $a) {\n    assertSame(\n        $a,\n        add($a, 0),\n    );\n}\n</code></pre></p> <p>With this 3 properties you virtually cover all possible operations that could be run. And this makes the implementation of <code>add</code> very difficult to get wrong.</p>"},{"location":"testing/property-based-testing/#more-realistic-example","title":"More realistic example","text":"<p>This kind of example is rarely the kind of things you'll have to test in a real program.</p> <p>A more concrete example that exists in many programs is user registration/login. Let's say that the registration workflow is a new user comes in and register, a confirmation email is sent, and once confirmed the user can login.</p> <p>The properties that you would have to verify are:</p> <ul> <li>Any new user (pair of identifier and password strings) can register</li> <li>Any new user can't login by default</li> <li>Any new user can't register twice</li> <li>A user can login after clicking the email confirmation link</li> </ul> <p>The first one verifies you can accept any pair of strings (no crash of your program). The second verifies the registration is partial and an extra step is required in order to login. The third one prevents duplicates in your database and sending multiple emails that would confuse the user. And the last one makes sure that it's the email extra step that allows the user to login.</p> <p>To find the properties of a system look for business rules that are always true. Do not try to put the whole business rules inside a single property. It's the combination of them that makes sure the system is correct.</p>"},{"location":"testing/tests/","title":"Tests","text":"<p>Before learning to write proofs and properties, you should familiarizes with BlackBox API by writing simple tests.</p>"},{"location":"testing/tests/#specific-scenario","title":"Specific scenario","text":"<p>If we reuse the <code>add</code> function:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n};\n\nApplication::new([])\n    -&gt;tryToProve(function() {\n        yield test(\n            'add(1, 2)',\n            static fn(Assert $assert) =&gt; $assert\n                -&gt;expected(3)\n                -&gt;same(add(1, 2)),\n        );\n    })\n    -&gt;exit();\n</code></pre> <p>Here we use a short function with only one assertion but you can run any number of assertions in a function.</p> <p>You should explore the <code>Assert</code>ion API with your code editor to discover all its capabilities.</p>"},{"location":"testing/tests/#same-scenario-for-multiple-values","title":"Same scenario for multiple values","text":"<p>Sometime you may want to run the same test but with a different set of values. Since declaring the tests is a generator you can do:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n};\n\nApplication::new([])\n    -&gt;tryToProve(function() {\n        $cases = [\n            [1, 2, 3],\n            [2, 3, 5],\n            // etc...\n        ];\n\n        foreach ($cases as [$a, $b, $expected]) {\n            yield test(\n                \"add($a, $b)\",\n                static fn(Assert $assert) =&gt; $assert\n                    -&gt;expected($expected)\n                    -&gt;same(add($a, $b)),\n            );\n        }\n    })\n    -&gt;exit();\n</code></pre>"},{"location":"use-cases/","title":"Use cases","text":"<p>In this chapter you'll find a set of use cases using packages already shown in previous chapters and a few other new ones.</p>"},{"location":"use-cases/copy-local-directory-to-s3/","title":"Copy a local directory to S3","text":"<pre><code>composer require innmind/s3 '~5.0'\n</code></pre> <pre><code>use Innmind\\S3;\nuse Innmind\\Url\\{\n    Url,\n    Path,\n};\n\n$bucket = S3\\Factory::of($os)-&gt;build(\n    Url::of('https://acces_key:acces_secret@bucket-name.s3.region-name.scw.cloud/'),\n    S3\\Region::of('region-name'),\n);\n$s3 = S3\\Filesystem\\Adapter::of($bucket);\n\n$directory = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some directory/'))\n    -&gt;unwrap()\n    -&gt;root();\n$s3-&gt;add($directory)-&gt;unwrap();\n</code></pre>"},{"location":"use-cases/creating-archive-directory/","title":"Creating an archive of a directory","text":"<pre><code>use Innmind\\Filesystem\\{\n    Name,\n    File\\Content,\n};\nuse Innmind\\Url\\Path;\nuse Innmind\\Encoding\\{\n    Gzip,\n    Tar,\n};\n\n$tar = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some/directory/'))\n    -&gt;unwrap()\n    -&gt;get(Name::of('data'))\n    -&gt;map(Tar::encode($os-&gt;clock()))\n    -&gt;map(Gzip::compress())\n    -&gt;match(\n        static fn(Content $file) =&gt; $file,\n        static fn() =&gt; throw new \\RuntimeException('Data not found'),\n    );\n</code></pre> <p>Here <code>$tar</code> represents a <code>.tar.gz</code> file containing all the files and directories from <code>some/directory/data/</code>.</p> <p>Info</p> <p>The content of the <code>$tar</code> file is lazily computed meaning you can create an archive larger than the allowed PHP memory.</p>"},{"location":"use-cases/persist-crawled-links-to-database/","title":"Persist crawled links to a database","text":"<pre><code>use Innmind\\Http\\{\n    Request,\n    Method,\n    ProtocolVersion,\n};\nuse Innmind\\Html\\{\n    Reader,\n    Visitor\\Elements,\n    Element\\A,\n};\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\Predicate\\Instance;\nuse Formal\\AccessLayer\\{\n    Query\\Insert,\n    Table\\Name,\n    Row,\n};\n\n$read = Reader::new();\n$sql = $os\n    -&gt;remote()\n    -&gt;sql(Url::of('mysql://127.0.0.1:3306/database_name'));\n\n$_ = $os\n    -&gt;remote()\n    -&gt;http()(Request::of(\n        Url::of('https://some-server.com/page.html')\n        Method::get,\n        ProtocolVersion::v11,\n    ))\n    -&gt;attempt(static fn() =&gt; new \\RuntimeException)\n    -&gt;map(static fn($success) =&gt; $success-&gt;response()-&gt;body())\n    -&gt;flatMap($read)\n    -&gt;maybe()\n    -&gt;toSequence()\n    -&gt;flatMap(Elements::of('a'))\n    -&gt;keep(Instance::of(A::class))\n    -&gt;map(static fn(A $a) =&gt; $a-&gt;href()-&gt;toString())\n    -&gt;foreach(static fn(string $href) =&gt; $sql(Insert::into(\n        Name::of('table_name'),\n        Row::of(['column_name' =&gt; $href]),\n    )));\n</code></pre>"},{"location":"use-cases/persist-sql-result-to-file/","title":"Persist a SQL result to a file","text":"<pre><code>use Innmind\\Filesystem\\{\n    File,\n    File\\Content,\n    File\\Content\\Line,\n};\nuse Innmind\\Url\\{\n    Url,\n    Path,\n};\nuse Innmind\\Immutable\\Str;\nuse Formal\\AccessLayer\\{\n    Query\\Select,\n    Table\\Name,\n};\n\n$sql = $os\n    -&gt;remote()\n    -&gt;sql(Url::of('mysql://127.0.0.1:3306/database_name'));\n\n$_ = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some directory/'))\n    -&gt;unwrap()\n    -&gt;add(File::named(\n        'results.csv',\n        Content::ofLines(\n            $sql(Select::onDemand(Name::of('table_name')))\n                -&gt;map(\n                    static fn($row) =&gt; $row\n                        -&gt;values()\n                        -&gt;map(static fn($value) =&gt; (string) $value-&gt;value()),\n                )\n                -&gt;map(Str::of(',')-&gt;join(...))\n                -&gt;map(Line::of(...)),\n        ),\n    ))\n    -&gt;unwrap();\n</code></pre> <p>Since the sql query is lazy (thanks to <code>::onDemand()</code>) you can persist a very long result without loading everything in memory.</p>"},{"location":"use-cases/serve-s3-file/","title":"Serve a S3 file via an HTTP server","text":"<pre><code>composer require innmind/s3 '~5.0'\n</code></pre> <pre><code>use Innmind\\Framework\\{\n    Application,\n    Main\\Http,\n    Http\\Route,\n};\nuse Innmind\\DI\\Service;\nuse Innmind\\S3;\nuse Innmind\\Filesystem\\{\n    Adapter,\n    Name,\n};\nuse Innmind\\Http\\{\n    ServerRequest,\n    Response,\n    Response\\StatusCode,\n    Headers,\n    Header\\ContentType,\n};\nuse Innmind\\MediaType\\MediaType;\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\Attempt;\n\nenum Services implements Service\n{\n    case s3;\n    case serve;\n}\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;service(Services::s3, static fn($_, $os) =&gt; S3\\Filesystem\\Adapter::of(\n                S3\\Factory::of($os)-&gt;build(\n                    Url::of('https://acces_key:acces_secret@bucket-name.s3.region-name.scw.cloud/'),\n                    S3\\Region::of('region-name'),\n                ),\n            ))\n            -&gt;service(Services::serve, static fn($get) =&gt; new class($get('s3')) {\n                public function __construct(private Adapter $s3){}\n\n                public function __invoke(ServerRequest $request): Attempt\n                {\n                    return Attempt::result(\n                        $this\n                            -&gt;s3\n                            -&gt;get(Name::of('some file.txt'))\n                            -&gt;match(\n                                static fn($file) =&gt; Response::of(\n                                    StatusCode::ok,\n                                    $request-&gt;protocolVersion(),\n                                    Headers::of(ContentType::of(new MediaType(\n                                        $file-&gt;mediaType()-&gt;topLevel(),\n                                        $file-&gt;mediaType()-&gt;subType(),\n                                    ))),\n                                    $file-&gt;content(),\n                                ),\n                                static fn() =&gt; Response::of(\n                                    StatusCode::notFound,\n                                    $request-&gt;protocolVersion(),\n                                ),\n                            ),\n                    );\n                }\n            })\n            -&gt;route(Route::get(\n                '/',\n                Services::serve,\n            ));\n    }\n};\n</code></pre> <p>Tip</p> <p>Head to the framework chapter to learn how to call this server.</p>"},{"location":"use-cases/upload-local-file/","title":"Upload a local file via HTTP","text":"<pre><code>use Innmind\\Filesystem\\Name;\nuse Innmind\\Http\\{\n    Message\\Request\\Request,\n    Message\\Method,\n    Content\\Multipart,\n    Header\\ContentType,\n    Header\\ContentType\\Boundary,\n    Headers,\n    ProtocolVersion,\n};\nuse Innmind\\Url\\{\n    Url,\n    Path,\n};\n\n$boundary = Boundary::uuid();\n$_ = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('some directory/'))\n    -&gt;unwrap()\n    -&gt;get(Name::of('your file.txt'))\n    -&gt;flatMap(\n        static fn($file) =&gt; $os\n            -&gt;remote()\n            -&gt;http()(Request::of(\n                Url::of('https://some-server.com/api/upload'),\n                Method::post,\n                ProtocolVersion::v11,\n                Headers::of($boundary-&gt;toHeader()),\n                Multipart::boundary($boundary)\n                    -&gt;withFile('some[file]', $file)\n                    -&gt;asContent(),\n            ))\n            -&gt;maybe(),\n    )\n    -&gt;match(\n        static fn() =&gt; null,\n        static fn() =&gt; throw new \\Exception('No file or failed to upload'),\n    );\n</code></pre>"},{"location":"use-cases/wait-server-start/","title":"Wait for a server to start","text":"<p>Let's say you want to start the PHP HTTP server to starting sending requests to it. Before sending requests you need to make sure it's up.</p> <p>You can do so with:</p> <pre><code>use Innmind\\Server\\Control\\Server\\{\n    Command,\n    Process\\Output\\Chunk,\n};\nuse Innmind\\Immutable\\Str;\n\n$process = $os\n    -&gt;control()\n    -&gt;processes()\n    -&gt;execute(\n        Command::foreground('php')\n            -&gt;withShortOption('S')\n            -&gt;withArgument('localhost:8080'),\n    )\n    -&gt;unwrap();\n$process\n    -&gt;output()\n    -&gt;map(static fn(Chunk $chunk) =&gt; $chunk-&gt;data())\n    -&gt;takeWhile(static fn(Str $chunk) =&gt; !$chunk-&gt;contains('started'))\n    -&gt;memoize();\n\n// you can send requests here\n</code></pre> <p>The <code>memoize</code> call is important because it's at this point that it will wait for an output chunk to contain the <code>started</code> text. Since by default the output use a deferred <code>Sequence</code> without the <code>memoize</code> it would do nothing (as if the code wasn't there at all).</p>"},{"location":"blog/archive/2024/","title":"2024","text":""}]}